<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/Yomguithereal/baobab"

    >baobab (v2.4.3)</a>
</h1>
<h4>JavaScript persistent data tree with cursors.</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.baobab">module baobab</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.baobab">
            function <span class="apidocSignatureSpan"></span>baobab
            <span class="apidocSignatureSpan">(initialData, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.Cursor">
            function <span class="apidocSignatureSpan">baobab.</span>Cursor
            <span class="apidocSignatureSpan">(tree, path, hash)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.Monkey">
            function <span class="apidocSignatureSpan">baobab.</span>Monkey
            <span class="apidocSignatureSpan">(tree, pathInTree, definition)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.MonkeyDefinition">
            function <span class="apidocSignatureSpan">baobab.</span>MonkeyDefinition
            <span class="apidocSignatureSpan">(definition)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.dynamicNode">
            function <span class="apidocSignatureSpan">baobab.</span>dynamicNode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.monkey">
            function <span class="apidocSignatureSpan">baobab.</span>monkey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">baobab.</span>Cursor.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">baobab.</span>helpers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">baobab.</span>type</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">baobab.</span>VERSION</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baobab.Cursor">module baobab.Cursor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.Cursor.Cursor">
            function <span class="apidocSignatureSpan">baobab.</span>Cursor
            <span class="apidocSignatureSpan">(tree, path, hash)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baobab.Cursor.prototype">module baobab.Cursor.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.Cursor.prototype.apply">
            function <span class="apidocSignatureSpan">baobab.Cursor.prototype.</span>apply
            <span class="apidocSignatureSpan">(path, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.Cursor.prototype.concat">
            function <span class="apidocSignatureSpan">baobab.Cursor.prototype.</span>concat
            <span class="apidocSignatureSpan">(path, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.Cursor.prototype.deepMerge">
            function <span class="apidocSignatureSpan">baobab.Cursor.prototype.</span>deepMerge
            <span class="apidocSignatureSpan">(path, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.Cursor.prototype.merge">
            function <span class="apidocSignatureSpan">baobab.Cursor.prototype.</span>merge
            <span class="apidocSignatureSpan">(path, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.Cursor.prototype.pop">
            function <span class="apidocSignatureSpan">baobab.Cursor.prototype.</span>pop
            <span class="apidocSignatureSpan">(path, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.Cursor.prototype.push">
            function <span class="apidocSignatureSpan">baobab.Cursor.prototype.</span>push
            <span class="apidocSignatureSpan">(path, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.Cursor.prototype.set">
            function <span class="apidocSignatureSpan">baobab.Cursor.prototype.</span>set
            <span class="apidocSignatureSpan">(path, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.Cursor.prototype.shift">
            function <span class="apidocSignatureSpan">baobab.Cursor.prototype.</span>shift
            <span class="apidocSignatureSpan">(path, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.Cursor.prototype.splice">
            function <span class="apidocSignatureSpan">baobab.Cursor.prototype.</span>splice
            <span class="apidocSignatureSpan">(path, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.Cursor.prototype.unset">
            function <span class="apidocSignatureSpan">baobab.Cursor.prototype.</span>unset
            <span class="apidocSignatureSpan">(path, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.Cursor.prototype.unshift">
            function <span class="apidocSignatureSpan">baobab.Cursor.prototype.</span>unshift
            <span class="apidocSignatureSpan">(path, value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baobab.helpers">module baobab.helpers</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.helpers.Archive">
            function <span class="apidocSignatureSpan">baobab.helpers.</span>Archive
            <span class="apidocSignatureSpan">(size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.helpers.arrayFrom">
            function <span class="apidocSignatureSpan">baobab.helpers.</span>arrayFrom
            <span class="apidocSignatureSpan">(culprit)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.helpers.before">
            function <span class="apidocSignatureSpan">baobab.helpers.</span>before
            <span class="apidocSignatureSpan">(decorator, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.helpers.coercePath">
            function <span class="apidocSignatureSpan">baobab.helpers.</span>coercePath
            <span class="apidocSignatureSpan">(target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.helpers.deepClone">
            function <span class="apidocSignatureSpan">baobab.helpers.</span>deepClone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.helpers.deepFreeze">
            function <span class="apidocSignatureSpan">baobab.helpers.</span>deepFreeze
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.helpers.deepMerge">
            function <span class="apidocSignatureSpan">baobab.helpers.</span>deepMerge
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.helpers.freeze">
            function <span class="apidocSignatureSpan">baobab.helpers.</span>freeze
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.helpers.getIn">
            function <span class="apidocSignatureSpan">baobab.helpers.</span>getIn
            <span class="apidocSignatureSpan">(object, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.helpers.makeError">
            function <span class="apidocSignatureSpan">baobab.helpers.</span>makeError
            <span class="apidocSignatureSpan">(message, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.helpers.shallowClone">
            function <span class="apidocSignatureSpan">baobab.helpers.</span>shallowClone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.helpers.shallowMerge">
            function <span class="apidocSignatureSpan">baobab.helpers.</span>shallowMerge
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.helpers.solveRelativePath">
            function <span class="apidocSignatureSpan">baobab.helpers.</span>solveRelativePath
            <span class="apidocSignatureSpan">(base, to)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.helpers.solveUpdate">
            function <span class="apidocSignatureSpan">baobab.helpers.</span>solveUpdate
            <span class="apidocSignatureSpan">(affectedPaths, comparedPaths)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.helpers.splice">
            function <span class="apidocSignatureSpan">baobab.helpers.</span>splice
            <span class="apidocSignatureSpan">(array, startIndex, nb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.helpers.uniqid">
            function <span class="apidocSignatureSpan">baobab.helpers.</span>uniqid
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baobab.type">module baobab.type</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.type.array">
            function <span class="apidocSignatureSpan">baobab.type.</span>array
            <span class="apidocSignatureSpan">(target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.type.dynamicPath">
            function <span class="apidocSignatureSpan">baobab.type.</span>dynamicPath
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.type.function">
            function <span class="apidocSignatureSpan">baobab.type.</span>function
            <span class="apidocSignatureSpan">(target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.type.lazyGetter">
            function <span class="apidocSignatureSpan">baobab.type.</span>lazyGetter
            <span class="apidocSignatureSpan">(o, propertyKey)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.type.monkeyDefinition">
            function <span class="apidocSignatureSpan">baobab.type.</span>monkeyDefinition
            <span class="apidocSignatureSpan">(definition)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.type.monkeyPath">
            function <span class="apidocSignatureSpan">baobab.type.</span>monkeyPath
            <span class="apidocSignatureSpan">(data, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.type.number">
            function <span class="apidocSignatureSpan">baobab.type.</span>number
            <span class="apidocSignatureSpan">(target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.type.object">
            function <span class="apidocSignatureSpan">baobab.type.</span>object
            <span class="apidocSignatureSpan">(target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.type.operationType">
            function <span class="apidocSignatureSpan">baobab.type.</span>operationType
            <span class="apidocSignatureSpan">(string)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.type.path">
            function <span class="apidocSignatureSpan">baobab.type.</span>path
            <span class="apidocSignatureSpan">(target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.type.primitive">
            function <span class="apidocSignatureSpan">baobab.type.</span>primitive
            <span class="apidocSignatureSpan">(target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.type.splicer">
            function <span class="apidocSignatureSpan">baobab.type.</span>splicer
            <span class="apidocSignatureSpan">(target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.type.string">
            function <span class="apidocSignatureSpan">baobab.type.</span>string
            <span class="apidocSignatureSpan">(target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.type.watcherMapping">
            function <span class="apidocSignatureSpan">baobab.type.</span>watcherMapping
            <span class="apidocSignatureSpan">(definition)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baobab" id="apidoc.module.baobab">module baobab</a></h1>


    <h2>
        <a href="#apidoc.element.baobab.baobab" id="apidoc.element.baobab.baobab">
        function <span class="apidocSignatureSpan"></span>baobab
        <span class="apidocSignatureSpan">(initialData, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Baobab(initialData, opts) {
  var _this = this;

  _classCallCheck(this, Baobab);

  _get(Object.getPrototypeOf(Baobab.prototype), &#x27;constructor&#x27;, this).call(this);

  // Setting initialData to an empty object if no data is provided by use
  if (arguments.length &#x3c; 1) initialData = {};

  // Checking whether given initial data is valid
  if (!_type2[&#x27;default&#x27;].object(initialData) &#x26;&#x26; !_type2[&#x27;default&#x27;].array(initialData)) throw makeError(&#x27;Baobab: invalid data.&#x27;, {
data: initialData });

  // Merging given options with defaults
  this.options = shallowMerge({}, DEFAULTS, opts);

  // Disabling immutability &#x26; persistence if persistence if disabled
  if (!this.options.persistent) {
    this.options.immutable = false;
    this.options.pure = false;
  }

  // Privates
  this._identity = &#x27;[object Baobab]&#x27;;
  this._cursors = {};
  this._future = null;
  this._transaction = [];
  this._affectedPathsIndex = {};
  this._monkeys = {};
  this._previousData = null;
  this._data = initialData;

  // Properties
  this.root = new _cursor2[&#x27;default&#x27;](this, [], &#x27;λ&#x27;);
  delete this.root.release;

  // Does the user want an immutable tree?
  if (this.options.immutable) deepFreeze(this._data);

  // Bootstrapping root cursor&#x27;s getters and setters
  var bootstrap = function bootstrap(name) {
    _this[name] = function () {
      var r = this.root[name].apply(this.root, arguments);
      return r instanceof _cursor2[&#x27;default&#x27;] ? this : r;
    };
  };

  [&#x27;apply&#x27;, &#x27;clone&#x27;, &#x27;concat&#x27;, &#x27;deepClone&#x27;, &#x27;deepMerge&#x27;, &#x27;exists&#x27;, &#x27;get&#x27;, &#x27;push&#x27;, &#x27;merge&#x27;, &#x27;pop&#x27;, &#x27;project&#x27;, &#x27;serialize&#x27;, &#x27;set&#x27;, &#x27;
shift&#x27;, &#x27;splice&#x27;, &#x27;unset&#x27;, &#x27;unshift&#x27;].forEach(bootstrap);

  // Registering the initial monkeys
  this._refreshMonkeys();

  // Initial validation
  var validationError = this.validate();

  if (validationError) throw Error(&#x27;Baobab: invalid data.&#x27;, { error: validationError });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.Cursor" id="apidoc.element.baobab.Cursor">
        function <span class="apidocSignatureSpan">baobab.</span>Cursor
        <span class="apidocSignatureSpan">(tree, path, hash)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Cursor(tree, path, hash) {
  var _this = this;

  _classCallCheck(this, Cursor);

  _get(Object.getPrototypeOf(Cursor.prototype), &#x27;constructor&#x27;, this).call(this);

  // If no path were to be provided, we fallback to an empty path (root)
  path = path || [];

  // Privates
  this._identity = &#x27;[object Cursor]&#x27;;
  this._archive = null;

  // Properties
  this.tree = tree;
  this.path = path;
  this.hash = hash;

  // State
  this.state = {
    killed: false,
    recording: false,
    undoing: false
  };

  // Checking whether the given path is dynamic or not
  this._dynamicPath = _type2[&#x27;default&#x27;].dynamicPath(this.path);

  // Checking whether the given path will meet a monkey
  this._monkeyPath = _type2[&#x27;default&#x27;].monkeyPath(this.tree._monkeys, this.path);

  if (!this._dynamicPath) this.solvedPath = this.path;else this.solvedPath = (0, _helpers.getIn)(this.tree._data, this.path).solvedPath
;

<span class="apidocCodeCommentSpan">  /**
   * Listener bound to the tree&#x27;s writes so that cursors with dynamic paths
   * may update their solved path correctly.
   *
   * @param {object} event - The event fired by the tree.
   */
</span>  this._writeHandler = function (_ref) {
    var data = _ref.data;

    if (_this.state.killed || !(0, _helpers.solveUpdate)([data.path], _this._getComparedPaths())) return;

    _this.solvedPath = (0, _helpers.getIn)(_this.tree._data, _this.path).solvedPath;
  };

  /**
   * Function in charge of actually trigger the cursor&#x27;s updates and
   * deal with the archived records.
   *
   * @note: probably should wrap the current solvedPath in closure to avoid
   * for tricky cases where it would fail.
   *
   * @param {mixed} previousData - the tree&#x27;s previous data.
   */
  var fireUpdate = function fireUpdate(previousData) {
    var self = _this;

    var eventData = Object.defineProperties({}, {
      previousData: {
        get: function get() {
          return (0, _helpers.getIn)(previousData, self.solvedPath).data;
        },
        configurable: true,
        enumerable: true
      },
      currentData: {
        get: function get() {
          return self.get();
        },
        configurable: true,
        enumerable: true
      }
    });

    if (_this.state.recording &#x26;&#x26; !_this.state.undoing) _this.archive.add(eventData.previousData);

    _this.state.undoing = false;

    return _this.emit(&#x27;update&#x27;, eventData);
  };

  /**
   * Listener bound to the tree&#x27;s updates and determining whether the
   * cursor is affected and should react accordingly.
   *
   * Note that this listener is lazily bound to the tree to be sure
   * one wouldn&#x27;t leak listeners when only creating cursors for convenience
   * and not to listen to updates specifically.
   *
   * @param {object} event - The event fired by the tree.
   */
  this._updateHandler = function (event) {
    if (_this.state.killed) return;

    var _event$data = event.data;
    var paths = _event$data.paths;
    var previousData = _event$data.previousData;
    var update = fireUpdate.bind(_this, previousData);
    var comparedPaths = _this._getComparedPaths();

    if ((0, _helpers.solveUpdate)(paths, comparedPaths)) return update();
  };

  // Lazy binding
  var bound = false;
  this._lazyBind = function () {
    if (bound) return;

    bound = true;

    if (_this._dynamicPath) _this.tree.on(&#x27;write&#x27;, _this._writeHandler);

    return _this.tree.on(&#x27;update&#x27;, _this._updateHandler);
  };

  // If the path is dynamic, we actually need to listen to the tree
  if (this._dynamicPath) {
    this._lazyBind();
  } else {

    // Overriding the emitter `on` and `once` methods
    this.on = (0, _helpers.before)(this._lazyBind, this.on.bind(this));
    this.once = (0, _helpers.before)(this._lazyBind, this.once.bind(this));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.Monkey" id="apidoc.element.baobab.Monkey">
        function <span class="apidocSignatureSpan">baobab.</span>Monkey
        <span class="apidocSignatureSpan">(tree, pathInTree, definition)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Monkey(tree, pathInTree, definition) {
  var _this2 = this;

  _classCallCheck(this, Monkey);

  // Properties
  this.tree = tree;
  this.path = pathInTree;
  this.definition = definition;

  // Adapting the definition&#x27;s paths &#x26; projection to this monkey&#x27;s case
  var projection = definition.projection,
      relative = _helpers.solveRelativePath.bind(null, pathInTree.slice(0, -1));

  if (definition.type === &#x27;object&#x27;) {
    this.projection = Object.keys(projection).reduce(function (acc, k) {
      acc[k] = relative(projection[k]);
      return acc;
    }, {});
    this.depPaths = Object.keys(this.projection).map(function (k) {
      return _this2.projection[k];
    });
  } else {
    this.projection = projection.map(relative);
    this.depPaths = this.projection;
  }

  // Internal state
  this.state = {
    killed: false
  };

<span class="apidocCodeCommentSpan">  /**
   * Listener on the tree&#x27;s `write` event.
   *
   * When the tree writes, this listener will check whether the updated paths
   * are of any use to the monkey and, if so, will update the tree&#x27;s node
   * where the monkey sits.
   */
</span>  this.writeListener = function (_ref) {
    var path = _ref.data.path;

    if (_this2.state.killed) return;

    // Is the monkey affected by the current write event?
    var concerned = (0, _helpers.solveUpdate)([path], _this2.relatedPaths());

    if (concerned) _this2.update();
  };

  /**
   * Listener on the tree&#x27;s `monkey` event.
   *
   * When another monkey updates, this listener will check whether the
   * updated paths are of any use to the monkey and, if so, will update the
   * tree&#x27;s node where the monkey sits.
   */
  this.recursiveListener = function (_ref2) {
    var _ref2$data = _ref2.data;
    var monkey = _ref2$data.monkey;
    var path = _ref2$data.path;

    if (_this2.state.killed) return;

    // Breaking if this is the same monkey
    if (_this2 === monkey) return;

    // Is the monkey affected by the current monkey event?
    var concerned = (0, _helpers.solveUpdate)([path], _this2.relatedPaths(false));

    if (concerned) _this2.update();
  };

  // Binding listeners
  this.tree.on(&#x27;write&#x27;, this.writeListener);
  this.tree.on(&#x27;_monkey&#x27;, this.recursiveListener);

  // Updating relevant node
  this.update();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.MonkeyDefinition" id="apidoc.element.baobab.MonkeyDefinition">
        function <span class="apidocSignatureSpan">baobab.</span>MonkeyDefinition
        <span class="apidocSignatureSpan">(definition)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MonkeyDefinition(definition) {
  var _this = this;

  _classCallCheck(this, MonkeyDefinition);

  var monkeyType = _type2[&#x27;default&#x27;].monkeyDefinition(definition);

  if (!monkeyType) throw (0, _helpers.makeError)(&#x27;Baobab.monkey: invalid definition.&#x27;, { definition: definition });

  this.type = monkeyType;

  if (this.type === &#x27;object&#x27;) {
    this.getter = definition.get;
    this.projection = definition.cursors || {};
    this.paths = Object.keys(this.projection).map(function (k) {
      return _this.projection[k];
    });
    this.options = definition.options || {};
  } else {
    var offset = 1,
        options = {};

    if (_type2[&#x27;default&#x27;].object(definition[definition.length - 1])) {
      offset++;
      options = definition[definition.length - 1];
    }

    this.getter = definition[definition.length - offset];
    this.projection = definition.slice(0, -offset);
    this.paths = this.projection;
    this.options = options;
  }

  // Coercing paths for convenience
  this.paths = this.paths.map(function (p) {
    return [].concat(p);
  });

  // Does the definition contain dynamic paths
  this.hasDynamicPaths = this.paths.some(_type2[&#x27;default&#x27;].dynamicPath);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.dynamicNode" id="apidoc.element.baobab.dynamicNode">
        function <span class="apidocSignatureSpan">baobab.</span>dynamicNode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dynamicNode = function () {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key &#x3c; _len; _key++) {
    args[_key] = arguments[_key];
  }

  if (!args.length) throw new Error(&#x27;Baobab.monkey: missing definition.&#x27;);

  if (args.length === 1 &#x26;&#x26; typeof args[0] !== &#x27;function&#x27;) return new _monkey.MonkeyDefinition(args[0]);

  return new _monkey.MonkeyDefinition(args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.monkey" id="apidoc.element.baobab.monkey">
        function <span class="apidocSignatureSpan">baobab.</span>monkey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">monkey = function () {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key &#x3c; _len; _key++) {
    args[_key] = arguments[_key];
  }

  if (!args.length) throw new Error(&#x27;Baobab.monkey: missing definition.&#x27;);

  if (args.length === 1 &#x26;&#x26; typeof args[0] !== &#x27;function&#x27;) return new _monkey.MonkeyDefinition(args[0]);

  return new _monkey.MonkeyDefinition(args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baobab.Cursor" id="apidoc.module.baobab.Cursor">module baobab.Cursor</a></h1>


    <h2>
        <a href="#apidoc.element.baobab.Cursor.Cursor" id="apidoc.element.baobab.Cursor.Cursor">
        function <span class="apidocSignatureSpan">baobab.</span>Cursor
        <span class="apidocSignatureSpan">(tree, path, hash)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Cursor(tree, path, hash) {
  var _this = this;

  _classCallCheck(this, Cursor);

  _get(Object.getPrototypeOf(Cursor.prototype), &#x27;constructor&#x27;, this).call(this);

  // If no path were to be provided, we fallback to an empty path (root)
  path = path || [];

  // Privates
  this._identity = &#x27;[object Cursor]&#x27;;
  this._archive = null;

  // Properties
  this.tree = tree;
  this.path = path;
  this.hash = hash;

  // State
  this.state = {
    killed: false,
    recording: false,
    undoing: false
  };

  // Checking whether the given path is dynamic or not
  this._dynamicPath = _type2[&#x27;default&#x27;].dynamicPath(this.path);

  // Checking whether the given path will meet a monkey
  this._monkeyPath = _type2[&#x27;default&#x27;].monkeyPath(this.tree._monkeys, this.path);

  if (!this._dynamicPath) this.solvedPath = this.path;else this.solvedPath = (0, _helpers.getIn)(this.tree._data, this.path).solvedPath
;

<span class="apidocCodeCommentSpan">  /**
   * Listener bound to the tree&#x27;s writes so that cursors with dynamic paths
   * may update their solved path correctly.
   *
   * @param {object} event - The event fired by the tree.
   */
</span>  this._writeHandler = function (_ref) {
    var data = _ref.data;

    if (_this.state.killed || !(0, _helpers.solveUpdate)([data.path], _this._getComparedPaths())) return;

    _this.solvedPath = (0, _helpers.getIn)(_this.tree._data, _this.path).solvedPath;
  };

  /**
   * Function in charge of actually trigger the cursor&#x27;s updates and
   * deal with the archived records.
   *
   * @note: probably should wrap the current solvedPath in closure to avoid
   * for tricky cases where it would fail.
   *
   * @param {mixed} previousData - the tree&#x27;s previous data.
   */
  var fireUpdate = function fireUpdate(previousData) {
    var self = _this;

    var eventData = Object.defineProperties({}, {
      previousData: {
        get: function get() {
          return (0, _helpers.getIn)(previousData, self.solvedPath).data;
        },
        configurable: true,
        enumerable: true
      },
      currentData: {
        get: function get() {
          return self.get();
        },
        configurable: true,
        enumerable: true
      }
    });

    if (_this.state.recording &#x26;&#x26; !_this.state.undoing) _this.archive.add(eventData.previousData);

    _this.state.undoing = false;

    return _this.emit(&#x27;update&#x27;, eventData);
  };

  /**
   * Listener bound to the tree&#x27;s updates and determining whether the
   * cursor is affected and should react accordingly.
   *
   * Note that this listener is lazily bound to the tree to be sure
   * one wouldn&#x27;t leak listeners when only creating cursors for convenience
   * and not to listen to updates specifically.
   *
   * @param {object} event - The event fired by the tree.
   */
  this._updateHandler = function (event) {
    if (_this.state.killed) return;

    var _event$data = event.data;
    var paths = _event$data.paths;
    var previousData = _event$data.previousData;
    var update = fireUpdate.bind(_this, previousData);
    var comparedPaths = _this._getComparedPaths();

    if ((0, _helpers.solveUpdate)(paths, comparedPaths)) return update();
  };

  // Lazy binding
  var bound = false;
  this._lazyBind = function () {
    if (bound) return;

    bound = true;

    if (_this._dynamicPath) _this.tree.on(&#x27;write&#x27;, _this._writeHandler);

    return _this.tree.on(&#x27;update&#x27;, _this._updateHandler);
  };

  // If the path is dynamic, we actually need to listen to the tree
  if (this._dynamicPath) {
    this._lazyBind();
  } else {

    // Overriding the emitter `on` and `once` methods
    this.on = (0, _helpers.before)(this._lazyBind, this.on.bind(this));
    this.once = (0, _helpers.before)(this._lazyBind, this.once.bind(this));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baobab.Cursor.prototype" id="apidoc.module.baobab.Cursor.prototype">module baobab.Cursor.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.baobab.Cursor.prototype.apply" id="apidoc.element.baobab.Cursor.prototype.apply">
        function <span class="apidocSignatureSpan">baobab.Cursor.prototype.</span>apply
        <span class="apidocSignatureSpan">(path, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">apply = function (path, value) {

  // We should warn the user if he applies to many arguments to the function
  if (arguments.length &#x3e; 2) throw (0, _helpers.makeError)(&#x27;Baobab.Cursor.&#x27; + name + &#x27;: too many arguments.&#x27;);

  // Handling arities
  if (arguments.length === 1 &#x26;&#x26; !INTRANSITIVE_SETTERS[name]) {
    value = path;
    path = [];
  }

  // Coerce path
  path = (0, _helpers.coercePath)(path);

  // Checking the path&#x27;s validity
  if (!_type2[&#x27;default&#x27;].path(path)) throw (0, _helpers.makeError)(&#x27;Baobab.Cursor.&#x27; + name + &#x27;: invalid path.&#x27;, { path: path });

  // Checking the value&#x27;s validity
  if (typeChecker &#x26;&#x26; !typeChecker(value)) throw (0, _helpers.makeError)(&#x27;Baobab.Cursor.&#x27; + name + &#x27;: invalid value.&#x27;, { path: path
, value: value });

  // Checking the solvability of the cursor&#x27;s dynamic path
  if (!this.solvedPath) throw (0, _helpers.makeError)(&#x27;Baobab.Cursor.&#x27; + name + &#x27;: the dynamic path of the cursor cannot be solved
.&#x27;, { path: this.path });

  var fullPath = this.solvedPath.concat(path);

  // Filing the update to the tree
  return this.tree.update(fullPath, {
    type: name,
    value: value
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
var inc = function(nb) {
  return nb + 1;
};

// Applying the function
var newList = cursor.<span class="apidocCodeKeywordSpan">apply</span>(inc);

// Applying the function at key
var newList = cursor.apply(&#x27;key&#x27;, inc);

// Applying the function at path
var newList = cursor.apply([&#x27;one&#x27;, &#x27;two&#x27;], inc);
var newList = cursor.select(&#x27;one&#x27;, &#x27;two&#x27;).apply(inc);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.Cursor.prototype.concat" id="apidoc.element.baobab.Cursor.prototype.concat">
        function <span class="apidocSignatureSpan">baobab.Cursor.prototype.</span>concat
        <span class="apidocSignatureSpan">(path, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">concat = function (path, value) {

  // We should warn the user if he applies to many arguments to the function
  if (arguments.length &#x3e; 2) throw (0, _helpers.makeError)(&#x27;Baobab.Cursor.&#x27; + name + &#x27;: too many arguments.&#x27;);

  // Handling arities
  if (arguments.length === 1 &#x26;&#x26; !INTRANSITIVE_SETTERS[name]) {
    value = path;
    path = [];
  }

  // Coerce path
  path = (0, _helpers.coercePath)(path);

  // Checking the path&#x27;s validity
  if (!_type2[&#x27;default&#x27;].path(path)) throw (0, _helpers.makeError)(&#x27;Baobab.Cursor.&#x27; + name + &#x27;: invalid path.&#x27;, { path: path });

  // Checking the value&#x27;s validity
  if (typeChecker &#x26;&#x26; !typeChecker(value)) throw (0, _helpers.makeError)(&#x27;Baobab.Cursor.&#x27; + name + &#x27;: invalid value.&#x27;, { path: path
, value: value });

  // Checking the solvability of the cursor&#x27;s dynamic path
  if (!this.solvedPath) throw (0, _helpers.makeError)(&#x27;Baobab.Cursor.&#x27; + name + &#x27;: the dynamic path of the cursor cannot be solved
.&#x27;, { path: this.path });

  var fullPath = this.solvedPath.concat(path);

  // Filing the update to the tree
  return this.tree.update(fullPath, {
    type: name,
    value: value
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

&#x3c;h5 id=&#x22;concat&#x22;&#x3e;tree/cursor.concat&#x3c;/h5&#x3e;

Concatenates a list into the selected list. This will of course fail if the selected node is not a list.

```js
// Concatenating a list
var newList = cursor.<span class="apidocCodeKeywordSpan">concat</span>(list);

// Concatenating a list in the list at key
var newList = cursor.concat(&#x27;key&#x27;, list);

// Concatenating into a nested path
var newList = cursor.concat([&#x27;one&#x27;, &#x27;two&#x27;], list);
var newList = cursor.select(&#x27;one&#x27;, &#x27;two&#x27;).concat(list);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.Cursor.prototype.deepMerge" id="apidoc.element.baobab.Cursor.prototype.deepMerge">
        function <span class="apidocSignatureSpan">baobab.Cursor.prototype.</span>deepMerge
        <span class="apidocSignatureSpan">(path, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deepMerge = function (path, value) {

  // We should warn the user if he applies to many arguments to the function
  if (arguments.length &#x3e; 2) throw (0, _helpers.makeError)(&#x27;Baobab.Cursor.&#x27; + name + &#x27;: too many arguments.&#x27;);

  // Handling arities
  if (arguments.length === 1 &#x26;&#x26; !INTRANSITIVE_SETTERS[name]) {
    value = path;
    path = [];
  }

  // Coerce path
  path = (0, _helpers.coercePath)(path);

  // Checking the path&#x27;s validity
  if (!_type2[&#x27;default&#x27;].path(path)) throw (0, _helpers.makeError)(&#x27;Baobab.Cursor.&#x27; + name + &#x27;: invalid path.&#x27;, { path: path });

  // Checking the value&#x27;s validity
  if (typeChecker &#x26;&#x26; !typeChecker(value)) throw (0, _helpers.makeError)(&#x27;Baobab.Cursor.&#x27; + name + &#x27;: invalid value.&#x27;, { path: path
, value: value });

  // Checking the solvability of the cursor&#x27;s dynamic path
  if (!this.solvedPath) throw (0, _helpers.makeError)(&#x27;Baobab.Cursor.&#x27; + name + &#x27;: the dynamic path of the cursor cannot be solved
.&#x27;, { path: this.path });

  var fullPath = this.solvedPath.concat(path);

  // Filing the update to the tree
  return this.tree.update(fullPath, {
    type: name,
    value: value
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

&#x3c;h5 id=&#x22;deepMerge&#x22;&#x3e;tree/cursor.deepMerge&#x3c;/h5&#x3e;

Deep merges the selected object with another one. This will of course fail if the selected node is not an object.

```js
// Merging
var newList = cursor.<span class="apidocCodeKeywordSpan">deepMerge</span>({user: {name: &#x27;John&#x27;}});

// Merging at key
var newList = cursor.deepMerge(&#x27;key&#x27;, {user: {name: &#x27;John&#x27;}});

// Merging at path
var newList = cursor.deepMerge([&#x27;one&#x27;, &#x27;two&#x27;], {user: {name: &#x27;John&#x27;}});
var newList = cursor.select(&#x27;one&#x27;, &#x27;two&#x27;).deepMerge({user: {name: &#x27;John&#x27;}});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.Cursor.prototype.merge" id="apidoc.element.baobab.Cursor.prototype.merge">
        function <span class="apidocSignatureSpan">baobab.Cursor.prototype.</span>merge
        <span class="apidocSignatureSpan">(path, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">merge = function (path, value) {

  // We should warn the user if he applies to many arguments to the function
  if (arguments.length &#x3e; 2) throw (0, _helpers.makeError)(&#x27;Baobab.Cursor.&#x27; + name + &#x27;: too many arguments.&#x27;);

  // Handling arities
  if (arguments.length === 1 &#x26;&#x26; !INTRANSITIVE_SETTERS[name]) {
    value = path;
    path = [];
  }

  // Coerce path
  path = (0, _helpers.coercePath)(path);

  // Checking the path&#x27;s validity
  if (!_type2[&#x27;default&#x27;].path(path)) throw (0, _helpers.makeError)(&#x27;Baobab.Cursor.&#x27; + name + &#x27;: invalid path.&#x27;, { path: path });

  // Checking the value&#x27;s validity
  if (typeChecker &#x26;&#x26; !typeChecker(value)) throw (0, _helpers.makeError)(&#x27;Baobab.Cursor.&#x27; + name + &#x27;: invalid value.&#x27;, { path: path
, value: value });

  // Checking the solvability of the cursor&#x27;s dynamic path
  if (!this.solvedPath) throw (0, _helpers.makeError)(&#x27;Baobab.Cursor.&#x27; + name + &#x27;: the dynamic path of the cursor cannot be solved
.&#x27;, { path: this.path });

  var fullPath = this.solvedPath.concat(path);

  // Filing the update to the tree
  return this.tree.update(fullPath, {
    type: name,
    value: value
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

&#x3c;h5 id=&#x22;merge&#x22;&#x3e;tree/cursor.merge&#x3c;/h5&#x3e;

Shallow merges the selected object with another one. This will of course fail if the selected node is not an object.

```js
// Merging
var newList = cursor.<span class="apidocCodeKeywordSpan">merge</span>({name: &#x27;John&#x27;});

// Merging at key
var newList = cursor.merge(&#x27;key&#x27;, {name: &#x27;John&#x27;});

// Merging at path
var newList = cursor.merge([&#x27;one&#x27;, &#x27;two&#x27;], {name: &#x27;John&#x27;});
var newList = cursor.select(&#x27;one&#x27;, &#x27;two&#x27;).merge({name: &#x27;John&#x27;});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.Cursor.prototype.pop" id="apidoc.element.baobab.Cursor.prototype.pop">
        function <span class="apidocSignatureSpan">baobab.Cursor.prototype.</span>pop
        <span class="apidocSignatureSpan">(path, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pop = function (path, value) {

  // We should warn the user if he applies to many arguments to the function
  if (arguments.length &#x3e; 2) throw (0, _helpers.makeError)(&#x27;Baobab.Cursor.&#x27; + name + &#x27;: too many arguments.&#x27;);

  // Handling arities
  if (arguments.length === 1 &#x26;&#x26; !INTRANSITIVE_SETTERS[name]) {
    value = path;
    path = [];
  }

  // Coerce path
  path = (0, _helpers.coercePath)(path);

  // Checking the path&#x27;s validity
  if (!_type2[&#x27;default&#x27;].path(path)) throw (0, _helpers.makeError)(&#x27;Baobab.Cursor.&#x27; + name + &#x27;: invalid path.&#x27;, { path: path });

  // Checking the value&#x27;s validity
  if (typeChecker &#x26;&#x26; !typeChecker(value)) throw (0, _helpers.makeError)(&#x27;Baobab.Cursor.&#x27; + name + &#x27;: invalid value.&#x27;, { path: path
, value: value });

  // Checking the solvability of the cursor&#x27;s dynamic path
  if (!this.solvedPath) throw (0, _helpers.makeError)(&#x27;Baobab.Cursor.&#x27; + name + &#x27;: the dynamic path of the cursor cannot be solved
.&#x27;, { path: this.path });

  var fullPath = this.solvedPath.concat(path);

  // Filing the update to the tree
  return this.tree.update(fullPath, {
    type: name,
    value: value
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

&#x3c;h5 id=&#x22;pop&#x22;&#x3e;tree/cursor.pop&#x3c;/h5&#x3e;

Removes the last item of the selected list. This will of course fail if the selected node is not a list.

```js
// Popping the list
var newList = cursor.<span class="apidocCodeKeywordSpan">pop</span>();

// Popping the list at key
var newList = cursor.pop(&#x27;key&#x27;);

// Popping list at path
var newList = cursor.pop([&#x27;one&#x27;, &#x27;two&#x27;]);
var newList = cursor.select(&#x27;one&#x27;, &#x27;two&#x27;).pop();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.Cursor.prototype.push" id="apidoc.element.baobab.Cursor.prototype.push">
        function <span class="apidocSignatureSpan">baobab.Cursor.prototype.</span>push
        <span class="apidocSignatureSpan">(path, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">push = function (path, value) {

  // We should warn the user if he applies to many arguments to the function
  if (arguments.length &#x3e; 2) throw (0, _helpers.makeError)(&#x27;Baobab.Cursor.&#x27; + name + &#x27;: too many arguments.&#x27;);

  // Handling arities
  if (arguments.length === 1 &#x26;&#x26; !INTRANSITIVE_SETTERS[name]) {
    value = path;
    path = [];
  }

  // Coerce path
  path = (0, _helpers.coercePath)(path);

  // Checking the path&#x27;s validity
  if (!_type2[&#x27;default&#x27;].path(path)) throw (0, _helpers.makeError)(&#x27;Baobab.Cursor.&#x27; + name + &#x27;: invalid path.&#x27;, { path: path });

  // Checking the value&#x27;s validity
  if (typeChecker &#x26;&#x26; !typeChecker(value)) throw (0, _helpers.makeError)(&#x27;Baobab.Cursor.&#x27; + name + &#x27;: invalid value.&#x27;, { path: path
, value: value });

  // Checking the solvability of the cursor&#x27;s dynamic path
  if (!this.solvedPath) throw (0, _helpers.makeError)(&#x27;Baobab.Cursor.&#x27; + name + &#x27;: the dynamic path of the cursor cannot be solved
.&#x27;, { path: this.path });

  var fullPath = this.solvedPath.concat(path);

  // Filing the update to the tree
  return this.tree.update(fullPath, {
    type: name,
    value: value
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var colorsCursor = tree.select(&#x27;palette&#x27;, &#x27;colors&#x27;);

colorsCursor.on(&#x27;update&#x27;, function() {
  console.log(&#x27;Selected colors have updated!&#x27;);
});

colorsCursor.<span class="apidocCodeKeywordSpan">push</span>(&#x27;orange&#x27;);
```

## Installation

If you want to use **Baobab** with node.js or browserify/webpack etc., you can use npm.

```sh
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.Cursor.prototype.set" id="apidoc.element.baobab.Cursor.prototype.set">
        function <span class="apidocSignatureSpan">baobab.Cursor.prototype.</span>set
        <span class="apidocSignatureSpan">(path, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (path, value) {

  // We should warn the user if he applies to many arguments to the function
  if (arguments.length &#x3e; 2) throw (0, _helpers.makeError)(&#x27;Baobab.Cursor.&#x27; + name + &#x27;: too many arguments.&#x27;);

  // Handling arities
  if (arguments.length === 1 &#x26;&#x26; !INTRANSITIVE_SETTERS[name]) {
    value = path;
    path = [];
  }

  // Coerce path
  path = (0, _helpers.coercePath)(path);

  // Checking the path&#x27;s validity
  if (!_type2[&#x27;default&#x27;].path(path)) throw (0, _helpers.makeError)(&#x27;Baobab.Cursor.&#x27; + name + &#x27;: invalid path.&#x27;, { path: path });

  // Checking the value&#x27;s validity
  if (typeChecker &#x26;&#x26; !typeChecker(value)) throw (0, _helpers.makeError)(&#x27;Baobab.Cursor.&#x27; + name + &#x27;: invalid value.&#x27;, { path: path
, value: value });

  // Checking the solvability of the cursor&#x27;s dynamic path
  if (!this.solvedPath) throw (0, _helpers.makeError)(&#x27;Baobab.Cursor.&#x27; + name + &#x27;: the dynamic path of the cursor cannot be solved
.&#x27;, { path: this.path });

  var fullPath = this.solvedPath.concat(path);

  // Filing the update to the tree
  return this.tree.update(fullPath, {
    type: name,
    value: value
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

*Example*

```js
var tree = new Baobab({hello: &#x27;world&#x27;});

var initialState = tree.get();
tree.<span class="apidocCodeKeywordSpan">set</span>(&#x27;hello&#x27;, &#x27;monde&#x27;);

// After asynchronous update...
assert(initialState !== tree.get());
```

---
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.Cursor.prototype.shift" id="apidoc.element.baobab.Cursor.prototype.shift">
        function <span class="apidocSignatureSpan">baobab.Cursor.prototype.</span>shift
        <span class="apidocSignatureSpan">(path, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shift = function (path, value) {

  // We should warn the user if he applies to many arguments to the function
  if (arguments.length &#x3e; 2) throw (0, _helpers.makeError)(&#x27;Baobab.Cursor.&#x27; + name + &#x27;: too many arguments.&#x27;);

  // Handling arities
  if (arguments.length === 1 &#x26;&#x26; !INTRANSITIVE_SETTERS[name]) {
    value = path;
    path = [];
  }

  // Coerce path
  path = (0, _helpers.coercePath)(path);

  // Checking the path&#x27;s validity
  if (!_type2[&#x27;default&#x27;].path(path)) throw (0, _helpers.makeError)(&#x27;Baobab.Cursor.&#x27; + name + &#x27;: invalid path.&#x27;, { path: path });

  // Checking the value&#x27;s validity
  if (typeChecker &#x26;&#x26; !typeChecker(value)) throw (0, _helpers.makeError)(&#x27;Baobab.Cursor.&#x27; + name + &#x27;: invalid value.&#x27;, { path: path
, value: value });

  // Checking the solvability of the cursor&#x27;s dynamic path
  if (!this.solvedPath) throw (0, _helpers.makeError)(&#x27;Baobab.Cursor.&#x27; + name + &#x27;: the dynamic path of the cursor cannot be solved
.&#x27;, { path: this.path });

  var fullPath = this.solvedPath.concat(path);

  // Filing the update to the tree
  return this.tree.update(fullPath, {
    type: name,
    value: value
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

&#x3c;h5 id=&#x22;shift&#x22;&#x3e;tree/cursor.shift&#x3c;/h5&#x3e;

Removes the first item of the selected list. This will of course fail if the selected node is not a list.

```js
// Shifting the list
var newList = cursor.<span class="apidocCodeKeywordSpan">shift</span>();

// Shifting the list at key
var newList = cursor.shift(&#x27;key&#x27;);

// Shifting list at path
var newList = cursor.shift([&#x27;one&#x27;, &#x27;two&#x27;]);
var newList = cursor.select(&#x27;one&#x27;, &#x27;two&#x27;).shift();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.Cursor.prototype.splice" id="apidoc.element.baobab.Cursor.prototype.splice">
        function <span class="apidocSignatureSpan">baobab.Cursor.prototype.</span>splice
        <span class="apidocSignatureSpan">(path, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">splice = function (path, value) {

  // We should warn the user if he applies to many arguments to the function
  if (arguments.length &#x3e; 2) throw (0, _helpers.makeError)(&#x27;Baobab.Cursor.&#x27; + name + &#x27;: too many arguments.&#x27;);

  // Handling arities
  if (arguments.length === 1 &#x26;&#x26; !INTRANSITIVE_SETTERS[name]) {
    value = path;
    path = [];
  }

  // Coerce path
  path = (0, _helpers.coercePath)(path);

  // Checking the path&#x27;s validity
  if (!_type2[&#x27;default&#x27;].path(path)) throw (0, _helpers.makeError)(&#x27;Baobab.Cursor.&#x27; + name + &#x27;: invalid path.&#x27;, { path: path });

  // Checking the value&#x27;s validity
  if (typeChecker &#x26;&#x26; !typeChecker(value)) throw (0, _helpers.makeError)(&#x27;Baobab.Cursor.&#x27; + name + &#x27;: invalid value.&#x27;, { path: path
, value: value });

  // Checking the solvability of the cursor&#x27;s dynamic path
  if (!this.solvedPath) throw (0, _helpers.makeError)(&#x27;Baobab.Cursor.&#x27; + name + &#x27;: the dynamic path of the cursor cannot be solved
.&#x27;, { path: this.path });

  var fullPath = this.solvedPath.concat(path);

  // Filing the update to the tree
  return this.tree.update(fullPath, {
    type: name,
    value: value
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

The `splice` specifications works the same as for [`Array.prototype.splice`](https://developer.mozilla.org/fr/docs/Web/JavaScript
/Reference/Objets_globaux/Array/splice).
There is one exception though: Per specification, splice deletes no values if the `deleteCount` argument is not parseable as a number
.
The `splice` implementation of Baobab instead throws an error, if the given `deleteCount` argument could not be parsed.

```js
// Splicing the list
var newList = cursor.<span class="apidocCodeKeywordSpan">splice</span>([1, 1]);

// Omitting the deleteCount argument makes splice delete no elements.
var newList = cursor.splice([1]);

// Inserting an item etc.
var newList = cursor.splice([1, 0, &#x27;newItem&#x27;]);
var newList = cursor.splice([1, 0, &#x27;newItem1&#x27;, &#x27;newItem2&#x27;]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.Cursor.prototype.unset" id="apidoc.element.baobab.Cursor.prototype.unset">
        function <span class="apidocSignatureSpan">baobab.Cursor.prototype.</span>unset
        <span class="apidocSignatureSpan">(path, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unset = function (path, value) {

  // We should warn the user if he applies to many arguments to the function
  if (arguments.length &#x3e; 2) throw (0, _helpers.makeError)(&#x27;Baobab.Cursor.&#x27; + name + &#x27;: too many arguments.&#x27;);

  // Handling arities
  if (arguments.length === 1 &#x26;&#x26; !INTRANSITIVE_SETTERS[name]) {
    value = path;
    path = [];
  }

  // Coerce path
  path = (0, _helpers.coercePath)(path);

  // Checking the path&#x27;s validity
  if (!_type2[&#x27;default&#x27;].path(path)) throw (0, _helpers.makeError)(&#x27;Baobab.Cursor.&#x27; + name + &#x27;: invalid path.&#x27;, { path: path });

  // Checking the value&#x27;s validity
  if (typeChecker &#x26;&#x26; !typeChecker(value)) throw (0, _helpers.makeError)(&#x27;Baobab.Cursor.&#x27; + name + &#x27;: invalid value.&#x27;, { path: path
, value: value });

  // Checking the solvability of the cursor&#x27;s dynamic path
  if (!this.solvedPath) throw (0, _helpers.makeError)(&#x27;Baobab.Cursor.&#x27; + name + &#x27;: the dynamic path of the cursor cannot be solved
.&#x27;, { path: this.path });

  var fullPath = this.solvedPath.concat(path);

  // Filing the update to the tree
  return this.tree.update(fullPath, {
    type: name,
    value: value
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Unsets the given key.

It will also work if you want to delete a list&#x27;s item.

```js
// Removing data at cursor
cursor.<span class="apidocCodeKeywordSpan">unset</span>();

// Removing a precise key
cursor.unset(&#x27;key&#x27;);

// Removing a nested key
cursor.unset([&#x27;one&#x27;, &#x27;two&#x27;]);
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.Cursor.prototype.unshift" id="apidoc.element.baobab.Cursor.prototype.unshift">
        function <span class="apidocSignatureSpan">baobab.Cursor.prototype.</span>unshift
        <span class="apidocSignatureSpan">(path, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unshift = function (path, value) {

  // We should warn the user if he applies to many arguments to the function
  if (arguments.length &#x3e; 2) throw (0, _helpers.makeError)(&#x27;Baobab.Cursor.&#x27; + name + &#x27;: too many arguments.&#x27;);

  // Handling arities
  if (arguments.length === 1 &#x26;&#x26; !INTRANSITIVE_SETTERS[name]) {
    value = path;
    path = [];
  }

  // Coerce path
  path = (0, _helpers.coercePath)(path);

  // Checking the path&#x27;s validity
  if (!_type2[&#x27;default&#x27;].path(path)) throw (0, _helpers.makeError)(&#x27;Baobab.Cursor.&#x27; + name + &#x27;: invalid path.&#x27;, { path: path });

  // Checking the value&#x27;s validity
  if (typeChecker &#x26;&#x26; !typeChecker(value)) throw (0, _helpers.makeError)(&#x27;Baobab.Cursor.&#x27; + name + &#x27;: invalid value.&#x27;, { path: path
, value: value });

  // Checking the solvability of the cursor&#x27;s dynamic path
  if (!this.solvedPath) throw (0, _helpers.makeError)(&#x27;Baobab.Cursor.&#x27; + name + &#x27;: the dynamic path of the cursor cannot be solved
.&#x27;, { path: this.path });

  var fullPath = this.solvedPath.concat(path);

  // Filing the update to the tree
  return this.tree.update(fullPath, {
    type: name,
    value: value
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

&#x3c;h5 id=&#x22;unshift&#x22;&#x3e;tree/cursor.unshift&#x3c;/h5&#x3e;

Unshifts a value into the selected list. This will of course fail if the selected node is not a list.

```js
// Unshifting a value
var newList = cursor.<span class="apidocCodeKeywordSpan">unshift</span>(newValue);

// Unshifting a value in the list at key
var newList = cursor.unshift(&#x27;key&#x27;, newValue);

// Unshifting into a nested path
var newList = cursor.unshift([&#x27;one&#x27;, &#x27;two&#x27;], newValue);
var newList = cursor.select(&#x27;one&#x27;, &#x27;two&#x27;).unshift(newValue);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baobab.helpers" id="apidoc.module.baobab.helpers">module baobab.helpers</a></h1>


    <h2>
        <a href="#apidoc.element.baobab.helpers.Archive" id="apidoc.element.baobab.helpers.Archive">
        function <span class="apidocSignatureSpan">baobab.helpers.</span>Archive
        <span class="apidocSignatureSpan">(size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Archive(size) {
  _classCallCheck(this, Archive);

  this.size = size;
  this.records = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.helpers.arrayFrom" id="apidoc.element.baobab.helpers.arrayFrom">
        function <span class="apidocSignatureSpan">baobab.helpers.</span>arrayFrom
        <span class="apidocSignatureSpan">(culprit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function arrayFrom(culprit) {
  return slice(culprit);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.helpers.before" id="apidoc.element.baobab.helpers.before">
        function <span class="apidocSignatureSpan">baobab.helpers.</span>before
        <span class="apidocSignatureSpan">(decorator, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function before(decorator, fn) {
  return function () {
    decorator.apply(null, arguments);
    fn.apply(null, arguments);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.helpers.coercePath" id="apidoc.element.baobab.helpers.coercePath">
        function <span class="apidocSignatureSpan">baobab.helpers.</span>coercePath
        <span class="apidocSignatureSpan">(target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function coercePath(target) {
  if (target || target === 0 || target === &#x27;&#x27;) return target;
  return [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.helpers.deepClone" id="apidoc.element.baobab.helpers.deepClone">
        function <span class="apidocSignatureSpan">baobab.helpers.</span>deepClone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deepClone = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.helpers.deepFreeze" id="apidoc.element.baobab.helpers.deepFreeze">
        function <span class="apidocSignatureSpan">baobab.helpers.</span>deepFreeze
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deepFreeze = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.helpers.deepMerge" id="apidoc.element.baobab.helpers.deepMerge">
        function <span class="apidocSignatureSpan">baobab.helpers.</span>deepMerge
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deepMerge = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...

&#x3c;h5 id=&#x22;deepMerge&#x22;&#x3e;tree/cursor.deepMerge&#x3c;/h5&#x3e;

Deep merges the selected object with another one. This will of course fail if the selected node is not an object.

```js
// Merging
var newList = cursor.<span class="apidocCodeKeywordSpan">deepMerge</span>({user: {name: &#x27;John&#x27;}});

// Merging at key
var newList = cursor.deepMerge(&#x27;key&#x27;, {user: {name: &#x27;John&#x27;}});

// Merging at path
var newList = cursor.deepMerge([&#x27;one&#x27;, &#x27;two&#x27;], {user: {name: &#x27;John&#x27;}});
var newList = cursor.select(&#x27;one&#x27;, &#x27;two&#x27;).deepMerge({user: {name: &#x27;John&#x27;}});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.helpers.freeze" id="apidoc.element.baobab.helpers.freeze">
        function <span class="apidocSignatureSpan">baobab.helpers.</span>freeze
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">freeze = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
function freezer(deep, o) {
  if (typeof o !== &#x27;object&#x27; ||
  o === null ||
  o instanceof Monkey)
return;

  Object.<span class="apidocCodeKeywordSpan">freeze</span>(o);

  if (!deep)
return;

  if (Array.isArray(o)) {

// Iterating through the elements
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.helpers.getIn" id="apidoc.element.baobab.helpers.getIn">
        function <span class="apidocSignatureSpan">baobab.helpers.</span>getIn
        <span class="apidocSignatureSpan">(object, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getIn(object, path) {
  if (!path) return NOT_FOUND_OBJECT;

  var solvedPath = [];

  var exists = true,
      c = object,
      idx = undefined,
      i = undefined,
      l = undefined;

  for (i = 0, l = path.length; i &#x3c; l; i++) {
    if (!c) return {
      data: undefined,
      solvedPath: solvedPath.concat(path.slice(i)),
      exists: false
    };

    if (typeof path[i] === &#x27;function&#x27;) {
      if (!_type2[&#x27;default&#x27;].array(c)) return NOT_FOUND_OBJECT;

      idx = index(c, path[i]);
      if (! ~idx) return NOT_FOUND_OBJECT;

      solvedPath.push(idx);
      c = c[idx];
    } else if (typeof path[i] === &#x27;object&#x27;) {
      if (!_type2[&#x27;default&#x27;].array(c)) return NOT_FOUND_OBJECT;

      idx = index(c, function (e) {
        return compare(e, path[i]);
      });
      if (! ~idx) return NOT_FOUND_OBJECT;

      solvedPath.push(idx);
      c = c[idx];
    } else {
      solvedPath.push(path[i]);
      exists = typeof c === &#x27;object&#x27; &#x26;&#x26; path[i] in c;
      c = c[path[i]];
    }
  }

  return { data: c, solvedPath: solvedPath, exists: exists };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.helpers.makeError" id="apidoc.element.baobab.helpers.makeError">
        function <span class="apidocSignatureSpan">baobab.helpers.</span>makeError
        <span class="apidocSignatureSpan">(message, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function makeError(message, data) {
  var err = new Error(message);

  for (var k in data) {
    err[k] = data[k];
  }return err;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.helpers.shallowClone" id="apidoc.element.baobab.helpers.shallowClone">
        function <span class="apidocSignatureSpan">baobab.helpers.</span>shallowClone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shallowClone = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.helpers.shallowMerge" id="apidoc.element.baobab.helpers.shallowMerge">
        function <span class="apidocSignatureSpan">baobab.helpers.</span>shallowMerge
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shallowMerge = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.helpers.solveRelativePath" id="apidoc.element.baobab.helpers.solveRelativePath">
        function <span class="apidocSignatureSpan">baobab.helpers.</span>solveRelativePath
        <span class="apidocSignatureSpan">(base, to)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function solveRelativePath(base, to) {
  var solvedPath = [];

  // Coercing to array
  to = [].concat(to);

  for (var i = 0, l = to.length; i &#x3c; l; i++) {
    var step = to[i];

    if (step === &#x27;.&#x27;) {
      if (!i) solvedPath = base.slice(0);
    } else if (step === &#x27;..&#x27;) {
      solvedPath = (!i ? base : solvedPath).slice(0, -1);
    } else {
      solvedPath.push(step);
    }
  }

  return solvedPath;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.helpers.solveUpdate" id="apidoc.element.baobab.helpers.solveUpdate">
        function <span class="apidocSignatureSpan">baobab.helpers.</span>solveUpdate
        <span class="apidocSignatureSpan">(affectedPaths, comparedPaths)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function solveUpdate(affectedPaths, comparedPaths) {
  var i = undefined,
      j = undefined,
      k = undefined,
      l = undefined,
      m = undefined,
      n = undefined,
      p = undefined,
      c = undefined,
      s = undefined;

  // Looping through possible paths
  for (i = 0, l = affectedPaths.length; i &#x3c; l; i++) {
    p = affectedPaths[i];

    if (!p.length) return true;

    // Looping through logged paths
    for (j = 0, m = comparedPaths.length; j &#x3c; m; j++) {
      c = comparedPaths[j];

      if (!c || !c.length) return true;

      // Looping through steps
      for (k = 0, n = c.length; k &#x3c; n; k++) {
        s = c[k];

        // If path is not relevant, we break
        // NOTE: the &#x27;!=&#x27; instead of &#x27;!==&#x27; is required here!
        if (s != p[k]) break;

        // If we reached last item and we are relevant
        if (k + 1 === n || k + 1 === p.length) return true;
      }
    }
  }

  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.helpers.splice" id="apidoc.element.baobab.helpers.splice">
        function <span class="apidocSignatureSpan">baobab.helpers.</span>splice
        <span class="apidocSignatureSpan">(array, startIndex, nb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function splice(array, startIndex, nb) {
  for (var _len2 = arguments.length, elements = Array(_len2 &#x3e; 3 ? _len2 - 3 : 0), _key2 = 3; _key2 &#x3c; _len2; _key2++) {
    elements[_key2 - 3] = arguments[_key2];
  }

  if (nb === undefined &#x26;&#x26; arguments.length === 2) nb = array.length - startIndex;else if (nb === null || nb === undefined) nb =
0;else if (isNaN(+nb)) throw new Error(&#x27;argument nb &#x27; + nb + &#x27; can not be parsed into a number!&#x27;);
  nb = Math.max(0, nb);

  // Solving startIndex
  if (_type2[&#x27;default&#x27;][&#x27;function&#x27;](startIndex)) startIndex = index(array, startIndex);
  if (_type2[&#x27;default&#x27;].object(startIndex)) startIndex = index(array, function (e) {
    return compare(e, startIndex);
  });

  // Positive index
  if (startIndex &#x3e;= 0) return array.slice(0, startIndex).concat(elements).concat(array.slice(startIndex + nb));

  // Negative index
  return array.slice(0, array.length + startIndex).concat(elements).concat(array.slice(array.length + startIndex + nb));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

The `splice` specifications works the same as for [`Array.prototype.splice`](https://developer.mozilla.org/fr/docs/Web/JavaScript
/Reference/Objets_globaux/Array/splice).
There is one exception though: Per specification, splice deletes no values if the `deleteCount` argument is not parseable as a number
.
The `splice` implementation of Baobab instead throws an error, if the given `deleteCount` argument could not be parsed.

```js
// Splicing the list
var newList = cursor.<span class="apidocCodeKeywordSpan">splice</span>([1, 1]);

// Omitting the deleteCount argument makes splice delete no elements.
var newList = cursor.splice([1]);

// Inserting an item etc.
var newList = cursor.splice([1, 0, &#x27;newItem&#x27;]);
var newList = cursor.splice([1, 0, &#x27;newItem1&#x27;, &#x27;newItem2&#x27;]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.helpers.uniqid" id="apidoc.element.baobab.helpers.uniqid">
        function <span class="apidocSignatureSpan">baobab.helpers.</span>uniqid
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">uniqid = function () {
  return i++;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baobab.type" id="apidoc.module.baobab.type">module baobab.type</a></h1>


    <h2>
        <a href="#apidoc.element.baobab.type.array" id="apidoc.element.baobab.type.array">
        function <span class="apidocSignatureSpan">baobab.type.</span>array
        <span class="apidocSignatureSpan">(target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">array = function (target) {
  return Array.isArray(target);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
super();

// Setting initialData to an empty object if no data is provided by use
if (arguments.length &#x3c; 1)
  initialData = {};

// Checking whether given initial data is valid
if (!type.object(initialData) &#x26;&#x26; !type.<span class="apidocCodeKeywordSpan">array</span>(initialData))
  throw makeError(&#x27;Baobab: invalid data.&#x27;, {data: initialData});

// Merging given options with defaults
this.options = shallowMerge({}, DEFAULTS, opts);

// Disabling immutability &#x26; persistence if persistence if disabled
if (!this.options.persistent) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.type.dynamicPath" id="apidoc.element.baobab.type.dynamicPath">
        function <span class="apidocSignatureSpan">baobab.type.</span>dynamicPath
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dynamicPath = function (path) {
  return path.some(function (step) {
    return type[&#x27;function&#x27;](step) || type.object(step);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.state = {
  killed: false,
  recording: false,
  undoing: false
};

// Checking whether the given path is dynamic or not
this._dynamicPath = type.<span class="apidocCodeKeywordSpan">dynamicPath</span>(this.path);

// Checking whether the given path will meet a monkey
this._monkeyPath = type.monkeyPath(this.tree._monkeys, this.path);

if (!this._dynamicPath)
  this.solvedPath = this.path;
else
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.type.function" id="apidoc.element.baobab.type.function">
        function <span class="apidocSignatureSpan">baobab.type.</span>function
        <span class="apidocSignatureSpan">(target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function = function (target) {
  return typeof target === &#x27;function&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * array.
 *
 * @param  {array}  path - The path to hash.
 * @return {string} string - The resultant hash.
 */
function hashPath(path) {
  return &#x27;λ&#x27; + path.map(step =&#x3e; {
    if (type.<span class="apidocCodeKeywordSpan">function</span>(step) || type.object(step))
      return `#${uniqid()}#`;

    return step;
  }).join(&#x27;λ&#x27;);
}

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.type.lazyGetter" id="apidoc.element.baobab.type.lazyGetter">
        function <span class="apidocSignatureSpan">baobab.type.</span>lazyGetter
        <span class="apidocSignatureSpan">(o, propertyKey)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lazyGetter = function (o, propertyKey) {
  var descriptor = Object.getOwnPropertyDescriptor(o, propertyKey);

  return descriptor &#x26;&#x26; descriptor.get &#x26;&#x26; descriptor.get.isLazyGetter === true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

let i, l, k;

// NOTE: could be possible to erase computed properties through `null`.
const props = Object.getOwnPropertyNames(item);
for (i = 0, l = props.length; i &#x3c; l; i++) {
  k = props[i];
  if (type.<span class="apidocCodeKeywordSpan">lazyGetter</span>(item, k)) {
    Object.defineProperty(o, k, {
      get: Object.getOwnPropertyDescriptor(item, k).get,
      enumerable: true,
      configurable: true
    });
  }
  else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.type.monkeyDefinition" id="apidoc.element.baobab.type.monkeyDefinition">
        function <span class="apidocSignatureSpan">baobab.type.</span>monkeyDefinition
        <span class="apidocSignatureSpan">(definition)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">monkeyDefinition = function (definition) {

  if (type.object(definition)) {
    if (!type[&#x27;function&#x27;](definition.get) || definition.cursors &#x26;&#x26; (!type.object(definition.cursors) || !Object.keys(definition.
cursors).every(function (k) {
      return type.path(definition.cursors[k]);
    }))) return null;

    return &#x27;object&#x27;;
  } else if (type.array(definition)) {
    var offset = 1;

    if (type.object(definition[definition.length - 1])) offset++;

    if (!type[&#x27;function&#x27;](definition[definition.length - offset]) || !definition.slice(0, -offset).every(function (p) {
      return type.path(p);
    })) return null;

    return &#x27;array&#x27;;
  }

  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * otherwise ordinary data.
 *
 * @constructor
 * @param {array|object} definition - The formal definition of the monkey.
 */
export class MonkeyDefinition {
  constructor(definition) {
const monkeyType = type.<span class="apidocCodeKeywordSpan">monkeyDefinition</span>(definition);

if (!monkeyType)
  throw makeError(
    &#x27;Baobab.monkey: invalid definition.&#x27;,
    {definition}
  );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.type.monkeyPath" id="apidoc.element.baobab.type.monkeyPath">
        function <span class="apidocSignatureSpan">baobab.type.</span>monkeyPath
        <span class="apidocSignatureSpan">(data, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">monkeyPath = function (data, path) {
  var subpath = [];

  var c = data,
      i = undefined,
      l = undefined;

  for (i = 0, l = path.length; i &#x3c; l; i++) {
    subpath.push(path[i]);

    if (typeof c !== &#x27;object&#x27;) return null;

    c = c[path[i]];

    if (c instanceof _monkey.Monkey) return subpath;
  }

  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// If we couldn&#x27;t solve the path, we throw
if (!solvedPath)
  throw makeError(&#x27;Baobab.update: could not solve the given path.&#x27;, {
    path: solvedPath
  });

// Read-only path?
const monkeyPath = type.<span class="apidocCodeKeywordSpan">monkeyPath</span>(this._monkeys, solvedPath);
if (monkeyPath &#x26;&#x26; solvedPath.length &#x3e; monkeyPath.length)
  throw makeError(&#x27;Baobab.update: attempting to update a read-only path.&#x27;, {
    path: solvedPath
  });

// We don&#x27;t unset irrelevant paths
if (operation.type === &#x27;unset&#x27; &#x26;&#x26; !exists)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.type.number" id="apidoc.element.baobab.type.number">
        function <span class="apidocSignatureSpan">baobab.type.</span>number
        <span class="apidocSignatureSpan">(target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">number = function (target) {
  return typeof target === &#x27;number&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.type.object" id="apidoc.element.baobab.type.object">
        function <span class="apidocSignatureSpan">baobab.type.</span>object
        <span class="apidocSignatureSpan">(target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">object = function (target) {
  return target &#x26;&#x26; typeof target === &#x27;object&#x27; &#x26;&#x26; !Array.isArray(target) &#x26;&#x26; !(target instanceof Date) &#x26;&#x26; !(target instanceof RegExp
) &#x26;&#x26; !(typeof Map === &#x27;function&#x27; &#x26;&#x26; target instanceof Map) &#x26;&#x26; !(typeof Set === &#x27;function&#x27; &#x26;&#x26; target instanceof Set);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * array.
 *
 * @param  {array}  path - The path to hash.
 * @return {string} string - The resultant hash.
 */
function hashPath(path) {
  return &#x27;λ&#x27; + path.map(step =&#x3e; {
    if (type.function(step) || type.<span class="apidocCodeKeywordSpan">object</span>(step))
      return `#${uniqid()}#`;

    return step;
  }).join(&#x27;λ&#x27;);
}

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.type.operationType" id="apidoc.element.baobab.type.operationType">
        function <span class="apidocSignatureSpan">baobab.type.</span>operationType
        <span class="apidocSignatureSpan">(string)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">operationType = function (string) {
  return typeof string === &#x27;string&#x27; &#x26;&#x26; !! ~VALID_OPERATIONS.indexOf(string);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @return {mixed} - Return the result of the update.
   */
  update(path, operation) {

// Coercing path
path = coercePath(path);

if (!type.<span class="apidocCodeKeywordSpan">operationType</span>(operation.type))
  throw makeError(
    `Baobab.update: unknown operation type &#x22;${operation.type}&#x22;.`,
    {operation}
  );

// Solving the given path
const {solvedPath, exists} = getIn(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.type.path" id="apidoc.element.baobab.type.path">
        function <span class="apidocSignatureSpan">baobab.type.</span>path
        <span class="apidocSignatureSpan">(target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">path = function (target) {
  if (!target &#x26;&#x26; target !== 0 &#x26;&#x26; target !== &#x27;&#x27;) return false;

  return [].concat(target).every(function (step) {
    return anyOf(step, ALLOWED_FOR_PATH);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
path = path || [];

// Variadic
if (arguments.length &#x3e; 1)
  path = arrayFrom(arguments);

// Checking that given path is valid
if (!type.<span class="apidocCodeKeywordSpan">path</span>(path))
  throw makeError(&#x27;Baobab.select: invalid path.&#x27;, {path});

// Casting to array
path = [].concat(path);

// Computing hash (done here because it would be too late to do it in the
// cursor&#x27;s constructor since we need to hit the cursors&#x27; index first).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.type.primitive" id="apidoc.element.baobab.type.primitive">
        function <span class="apidocSignatureSpan">baobab.type.</span>primitive
        <span class="apidocSignatureSpan">(target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">primitive = function (target) {
  return target !== Object(target);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Method returning whether the cursor is at leaf level.
 *
 * @return {boolean} - Is the cursor a leaf?
 */
isLeaf() {
  return type.<span class="apidocCodeKeywordSpan">primitive</span>(this._get().data);
}

/**
 * Method returning whether the cursor is at branch level.
 *
 * @return {boolean} - Is the cursor a branch?
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.type.splicer" id="apidoc.element.baobab.type.splicer">
        function <span class="apidocSignatureSpan">baobab.type.</span>splicer
        <span class="apidocSignatureSpan">(target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">splicer = function (target) {
  if (!type.array(target) || target.length &#x3c; 1) return false;
  if (target.length &#x3e; 1 &#x26;&#x26; isNaN(+target[1])) return false;

  return anyOf(target[0], [&#x27;number&#x27;, &#x27;function&#x27;, &#x27;object&#x27;]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.type.string" id="apidoc.element.baobab.type.string">
        function <span class="apidocSignatureSpan">baobab.type.</span>string
        <span class="apidocSignatureSpan">(target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">string = function (target) {
  return typeof target === &#x27;string&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.type.watcherMapping" id="apidoc.element.baobab.type.watcherMapping">
        function <span class="apidocSignatureSpan">baobab.type.</span>watcherMapping
        <span class="apidocSignatureSpan">(definition)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">watcherMapping = function (definition) {
  return type.object(definition) &#x26;&#x26; Object.keys(definition).every(function (k) {
    return type.path(definition[k]);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * Method used to refresh the watcher&#x27;s mapping.
   *
   * @param  {object}  mapping  - The new mapping to apply.
   * @return {Watcher}          - Itself for chaining purposes.
   */
  refresh(mapping) {

if (!type.<span class="apidocCodeKeywordSpan">watcherMapping</span>(mapping))
  throw makeError(&#x27;Baobab.watch: invalid mapping.&#x27;, {mapping});

this.mapping = mapping;

// Creating the get method
const projection = {};
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
