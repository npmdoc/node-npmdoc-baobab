<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/Yomguithereal/baobab">baobab (v2.4.3)</a>
</h1>
<h4>JavaScript persistent data tree with cursors.</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.baobab">module baobab</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.baobab">
            function <span class="apidocSignatureSpan"></span>baobab
            <span class="apidocSignatureSpan">(initialData, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.Cursor">
            function <span class="apidocSignatureSpan">baobab.</span>Cursor
            <span class="apidocSignatureSpan">(tree, path, hash)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.Monkey">
            function <span class="apidocSignatureSpan">baobab.</span>Monkey
            <span class="apidocSignatureSpan">(tree, pathInTree, definition)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.MonkeyDefinition">
            function <span class="apidocSignatureSpan">baobab.</span>MonkeyDefinition
            <span class="apidocSignatureSpan">(definition)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.dynamicNode">
            function <span class="apidocSignatureSpan">baobab.</span>dynamicNode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.monkey">
            function <span class="apidocSignatureSpan">baobab.</span>monkey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">baobab.</span>Cursor.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">baobab.</span>helpers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">baobab.</span>type</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">baobab.</span>VERSION</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baobab.Cursor">module baobab.Cursor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.Cursor.Cursor">
            function <span class="apidocSignatureSpan">baobab.</span>Cursor
            <span class="apidocSignatureSpan">(tree, path, hash)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baobab.Cursor.prototype">module baobab.Cursor.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.Cursor.prototype.apply">
            function <span class="apidocSignatureSpan">baobab.Cursor.prototype.</span>apply
            <span class="apidocSignatureSpan">(path, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.Cursor.prototype.concat">
            function <span class="apidocSignatureSpan">baobab.Cursor.prototype.</span>concat
            <span class="apidocSignatureSpan">(path, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.Cursor.prototype.deepMerge">
            function <span class="apidocSignatureSpan">baobab.Cursor.prototype.</span>deepMerge
            <span class="apidocSignatureSpan">(path, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.Cursor.prototype.merge">
            function <span class="apidocSignatureSpan">baobab.Cursor.prototype.</span>merge
            <span class="apidocSignatureSpan">(path, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.Cursor.prototype.pop">
            function <span class="apidocSignatureSpan">baobab.Cursor.prototype.</span>pop
            <span class="apidocSignatureSpan">(path, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.Cursor.prototype.push">
            function <span class="apidocSignatureSpan">baobab.Cursor.prototype.</span>push
            <span class="apidocSignatureSpan">(path, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.Cursor.prototype.set">
            function <span class="apidocSignatureSpan">baobab.Cursor.prototype.</span>set
            <span class="apidocSignatureSpan">(path, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.Cursor.prototype.shift">
            function <span class="apidocSignatureSpan">baobab.Cursor.prototype.</span>shift
            <span class="apidocSignatureSpan">(path, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.Cursor.prototype.splice">
            function <span class="apidocSignatureSpan">baobab.Cursor.prototype.</span>splice
            <span class="apidocSignatureSpan">(path, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.Cursor.prototype.unset">
            function <span class="apidocSignatureSpan">baobab.Cursor.prototype.</span>unset
            <span class="apidocSignatureSpan">(path, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.Cursor.prototype.unshift">
            function <span class="apidocSignatureSpan">baobab.Cursor.prototype.</span>unshift
            <span class="apidocSignatureSpan">(path, value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baobab.helpers">module baobab.helpers</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.helpers.Archive">
            function <span class="apidocSignatureSpan">baobab.helpers.</span>Archive
            <span class="apidocSignatureSpan">(size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.helpers.arrayFrom">
            function <span class="apidocSignatureSpan">baobab.helpers.</span>arrayFrom
            <span class="apidocSignatureSpan">(culprit)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.helpers.before">
            function <span class="apidocSignatureSpan">baobab.helpers.</span>before
            <span class="apidocSignatureSpan">(decorator, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.helpers.coercePath">
            function <span class="apidocSignatureSpan">baobab.helpers.</span>coercePath
            <span class="apidocSignatureSpan">(target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.helpers.deepClone">
            function <span class="apidocSignatureSpan">baobab.helpers.</span>deepClone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.helpers.deepFreeze">
            function <span class="apidocSignatureSpan">baobab.helpers.</span>deepFreeze
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.helpers.deepMerge">
            function <span class="apidocSignatureSpan">baobab.helpers.</span>deepMerge
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.helpers.freeze">
            function <span class="apidocSignatureSpan">baobab.helpers.</span>freeze
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.helpers.getIn">
            function <span class="apidocSignatureSpan">baobab.helpers.</span>getIn
            <span class="apidocSignatureSpan">(object, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.helpers.makeError">
            function <span class="apidocSignatureSpan">baobab.helpers.</span>makeError
            <span class="apidocSignatureSpan">(message, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.helpers.shallowClone">
            function <span class="apidocSignatureSpan">baobab.helpers.</span>shallowClone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.helpers.shallowMerge">
            function <span class="apidocSignatureSpan">baobab.helpers.</span>shallowMerge
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.helpers.solveRelativePath">
            function <span class="apidocSignatureSpan">baobab.helpers.</span>solveRelativePath
            <span class="apidocSignatureSpan">(base, to)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.helpers.solveUpdate">
            function <span class="apidocSignatureSpan">baobab.helpers.</span>solveUpdate
            <span class="apidocSignatureSpan">(affectedPaths, comparedPaths)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.helpers.splice">
            function <span class="apidocSignatureSpan">baobab.helpers.</span>splice
            <span class="apidocSignatureSpan">(array, startIndex, nb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.helpers.uniqid">
            function <span class="apidocSignatureSpan">baobab.helpers.</span>uniqid
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baobab.type">module baobab.type</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.type.array">
            function <span class="apidocSignatureSpan">baobab.type.</span>array
            <span class="apidocSignatureSpan">(target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.type.dynamicPath">
            function <span class="apidocSignatureSpan">baobab.type.</span>dynamicPath
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.type.function">
            function <span class="apidocSignatureSpan">baobab.type.</span>function
            <span class="apidocSignatureSpan">(target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.type.lazyGetter">
            function <span class="apidocSignatureSpan">baobab.type.</span>lazyGetter
            <span class="apidocSignatureSpan">(o, propertyKey)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.type.monkeyDefinition">
            function <span class="apidocSignatureSpan">baobab.type.</span>monkeyDefinition
            <span class="apidocSignatureSpan">(definition)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.type.monkeyPath">
            function <span class="apidocSignatureSpan">baobab.type.</span>monkeyPath
            <span class="apidocSignatureSpan">(data, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.type.number">
            function <span class="apidocSignatureSpan">baobab.type.</span>number
            <span class="apidocSignatureSpan">(target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.type.object">
            function <span class="apidocSignatureSpan">baobab.type.</span>object
            <span class="apidocSignatureSpan">(target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.type.operationType">
            function <span class="apidocSignatureSpan">baobab.type.</span>operationType
            <span class="apidocSignatureSpan">(string)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.type.path">
            function <span class="apidocSignatureSpan">baobab.type.</span>path
            <span class="apidocSignatureSpan">(target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.type.primitive">
            function <span class="apidocSignatureSpan">baobab.type.</span>primitive
            <span class="apidocSignatureSpan">(target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.type.splicer">
            function <span class="apidocSignatureSpan">baobab.type.</span>splicer
            <span class="apidocSignatureSpan">(target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.type.string">
            function <span class="apidocSignatureSpan">baobab.type.</span>string
            <span class="apidocSignatureSpan">(target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baobab.type.watcherMapping">
            function <span class="apidocSignatureSpan">baobab.type.</span>watcherMapping
            <span class="apidocSignatureSpan">(definition)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baobab" id="apidoc.module.baobab">module baobab</a></h1>


    <h2>
        <a href="#apidoc.element.baobab.baobab" id="apidoc.element.baobab.baobab">
        function <span class="apidocSignatureSpan"></span>baobab
        <span class="apidocSignatureSpan">(initialData, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Baobab(initialData, opts) {
  var _this = this;

  _classCallCheck(this, Baobab);

  _get(Object.getPrototypeOf(Baobab.prototype), 'constructor', this).call(this);

  // Setting initialData to an empty object if no data is provided by use
  if (arguments.length &lt; 1) initialData = {};

  // Checking whether given initial data is valid
  if (!_type2['default'].object(initialData) &amp;&amp; !_type2['default'].array(initialData)) throw makeError('Baobab: invalid data.', {
data: initialData });

  // Merging given options with defaults
  this.options = shallowMerge({}, DEFAULTS, opts);

  // Disabling immutability &amp; persistence if persistence if disabled
  if (!this.options.persistent) {
    this.options.immutable = false;
    this.options.pure = false;
  }

  // Privates
  this._identity = '[object Baobab]';
  this._cursors = {};
  this._future = null;
  this._transaction = [];
  this._affectedPathsIndex = {};
  this._monkeys = {};
  this._previousData = null;
  this._data = initialData;

  // Properties
  this.root = new _cursor2['default'](this, [], 'Î»');
  delete this.root.release;

  // Does the user want an immutable tree?
  if (this.options.immutable) deepFreeze(this._data);

  // Bootstrapping root cursor's getters and setters
  var bootstrap = function bootstrap(name) {
    _this[name] = function () {
      var r = this.root[name].apply(this.root, arguments);
      return r instanceof _cursor2['default'] ? this : r;
    };
  };

  ['apply', 'clone', 'concat', 'deepClone', 'deepMerge', 'exists', 'get', 'push', 'merge', 'pop', 'project', 'serialize', 'set', '
shift', 'splice', 'unset', 'unshift'].forEach(bootstrap);

  // Registering the initial monkeys
  this._refreshMonkeys();

  // Initial validation
  var validationError = this.validate();

  if (validationError) throw Error('Baobab: invalid data.', { error: validationError });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.Cursor" id="apidoc.element.baobab.Cursor">
        function <span class="apidocSignatureSpan">baobab.</span>Cursor
        <span class="apidocSignatureSpan">(tree, path, hash)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Cursor(tree, path, hash) {
  var _this = this;

  _classCallCheck(this, Cursor);

  _get(Object.getPrototypeOf(Cursor.prototype), 'constructor', this).call(this);

  // If no path were to be provided, we fallback to an empty path (root)
  path = path || [];

  // Privates
  this._identity = '[object Cursor]';
  this._archive = null;

  // Properties
  this.tree = tree;
  this.path = path;
  this.hash = hash;

  // State
  this.state = {
    killed: false,
    recording: false,
    undoing: false
  };

  // Checking whether the given path is dynamic or not
  this._dynamicPath = _type2['default'].dynamicPath(this.path);

  // Checking whether the given path will meet a monkey
  this._monkeyPath = _type2['default'].monkeyPath(this.tree._monkeys, this.path);

  if (!this._dynamicPath) this.solvedPath = this.path;else this.solvedPath = (0, _helpers.getIn)(this.tree._data, this.path).solvedPath
;

<span class="apidocCodeCommentSpan">  /**
   * Listener bound to the tree's writes so that cursors with dynamic paths
   * may update their solved path correctly.
   *
   * @param {object} event - The event fired by the tree.
   */
</span>  this._writeHandler = function (_ref) {
    var data = _ref.data;

    if (_this.state.killed || !(0, _helpers.solveUpdate)([data.path], _this._getComparedPaths())) return;

    _this.solvedPath = (0, _helpers.getIn)(_this.tree._data, _this.path).solvedPath;
  };

  /**
   * Function in charge of actually trigger the cursor's updates and
   * deal with the archived records.
   *
   * @note: probably should wrap the current solvedPath in closure to avoid
   * for tricky cases where it would fail.
   *
   * @param {mixed} previousData - the tree's previous data.
   */
  var fireUpdate = function fireUpdate(previousData) {
    var self = _this;

    var eventData = Object.defineProperties({}, {
      previousData: {
        get: function get() {
          return (0, _helpers.getIn)(previousData, self.solvedPath).data;
        },
        configurable: true,
        enumerable: true
      },
      currentData: {
        get: function get() {
          return self.get();
        },
        configurable: true,
        enumerable: true
      }
    });

    if (_this.state.recording &amp;&amp; !_this.state.undoing) _this.archive.add(eventData.previousData);

    _this.state.undoing = false;

    return _this.emit('update', eventData);
  };

  /**
   * Listener bound to the tree's updates and determining whether the
   * cursor is affected and should react accordingly.
   *
   * Note that this listener is lazily bound to the tree to be sure
   * one wouldn't leak listeners when only creating cursors for convenience
   * and not to listen to updates specifically.
   *
   * @param {object} event - The event fired by the tree.
   */
  this._updateHandler = function (event) {
    if (_this.state.killed) return;

    var _event$data = event.data;
    var paths = _event$data.paths;
    var previousData = _event$data.previousData;
    var update = fireUpdate.bind(_this, previousData);
    var comparedPaths = _this._getComparedPaths();

    if ((0, _helpers.solveUpdate)(paths, comparedPaths)) return update();
  };

  // Lazy binding
  var bound = false;
  this._lazyBind = function () {
    if (bound) return;

    bound = true;

    if (_this._dynamicPath) _this.tree.on('write', _this._writeHandler);

    return _this.tree.on('update', _this._updateHandler);
  };

  // If the path is dynamic, we actually need to listen to the tree
  if (this._dynamicPath) {
    this._lazyBind();
  } else {

    // Overriding the emitter `on` and `once` methods
    this.on = (0, _helpers.before)(this._lazyBind, this.on.bind(this));
    this.once = (0, _helpers.before)(this._lazyBind, this.once.bind(this));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.Monkey" id="apidoc.element.baobab.Monkey">
        function <span class="apidocSignatureSpan">baobab.</span>Monkey
        <span class="apidocSignatureSpan">(tree, pathInTree, definition)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Monkey(tree, pathInTree, definition) {
  var _this2 = this;

  _classCallCheck(this, Monkey);

  // Properties
  this.tree = tree;
  this.path = pathInTree;
  this.definition = definition;

  // Adapting the definition's paths &amp; projection to this monkey's case
  var projection = definition.projection,
      relative = _helpers.solveRelativePath.bind(null, pathInTree.slice(0, -1));

  if (definition.type === 'object') {
    this.projection = Object.keys(projection).reduce(function (acc, k) {
      acc[k] = relative(projection[k]);
      return acc;
    }, {});
    this.depPaths = Object.keys(this.projection).map(function (k) {
      return _this2.projection[k];
    });
  } else {
    this.projection = projection.map(relative);
    this.depPaths = this.projection;
  }

  // Internal state
  this.state = {
    killed: false
  };

<span class="apidocCodeCommentSpan">  /**
   * Listener on the tree's `write` event.
   *
   * When the tree writes, this listener will check whether the updated paths
   * are of any use to the monkey and, if so, will update the tree's node
   * where the monkey sits.
   */
</span>  this.writeListener = function (_ref) {
    var path = _ref.data.path;

    if (_this2.state.killed) return;

    // Is the monkey affected by the current write event?
    var concerned = (0, _helpers.solveUpdate)([path], _this2.relatedPaths());

    if (concerned) _this2.update();
  };

  /**
   * Listener on the tree's `monkey` event.
   *
   * When another monkey updates, this listener will check whether the
   * updated paths are of any use to the monkey and, if so, will update the
   * tree's node where the monkey sits.
   */
  this.recursiveListener = function (_ref2) {
    var _ref2$data = _ref2.data;
    var monkey = _ref2$data.monkey;
    var path = _ref2$data.path;

    if (_this2.state.killed) return;

    // Breaking if this is the same monkey
    if (_this2 === monkey) return;

    // Is the monkey affected by the current monkey event?
    var concerned = (0, _helpers.solveUpdate)([path], _this2.relatedPaths(false));

    if (concerned) _this2.update();
  };

  // Binding listeners
  this.tree.on('write', this.writeListener);
  this.tree.on('_monkey', this.recursiveListener);

  // Updating relevant node
  this.update();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      };

      var walk = function walk(data) {
        var p = arguments.length &lt;= 1 || arguments[1] === undefined ? [] : arguments[1];

        // Should we sit a monkey in the tree?
        if (data instanceof _monkey.MonkeyDefinition || data instanceof _monkey.Monkey) {
var monkeyInstance = new _monkey.<span class="apidocCodeKeywordSpan">Monkey</span>(_this2, p, data instanceof _monkey.Monkey ? data
.definition : data);

(0, _update3['default'])(_this2._monkeys, p, { type: 'set', value: monkeyInstance }, {
  immutable: false,
  persistent: false,
  pure: false
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.MonkeyDefinition" id="apidoc.element.baobab.MonkeyDefinition">
        function <span class="apidocSignatureSpan">baobab.</span>MonkeyDefinition
        <span class="apidocSignatureSpan">(definition)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MonkeyDefinition(definition) {
  var _this = this;

  _classCallCheck(this, MonkeyDefinition);

  var monkeyType = _type2['default'].monkeyDefinition(definition);

  if (!monkeyType) throw (0, _helpers.makeError)('Baobab.monkey: invalid definition.', { definition: definition });

  this.type = monkeyType;

  if (this.type === 'object') {
    this.getter = definition.get;
    this.projection = definition.cursors || {};
    this.paths = Object.keys(this.projection).map(function (k) {
      return _this.projection[k];
    });
    this.options = definition.options || {};
  } else {
    var offset = 1,
        options = {};

    if (_type2['default'].object(definition[definition.length - 1])) {
      offset++;
      options = definition[definition.length - 1];
    }

    this.getter = definition[definition.length - offset];
    this.projection = definition.slice(0, -offset);
    this.paths = this.projection;
    this.options = options;
  }

  // Coercing paths for convenience
  this.paths = this.paths.map(function (p) {
    return [].concat(p);
  });

  // Does the definition contain dynamic paths
  this.hasDynamicPaths = this.paths.some(_type2['default'].dynamicPath);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Baobab.monkey = function () {
 for (var _len = arguments.length, args = Array(_len), _key = 0; _key &lt; _len; _key++) {
   args[_key] = arguments[_key];
 }

 if (!args.length) throw new Error('Baobab.monkey: missing definition.');

 if (args.length === 1 &amp;&amp; typeof args[0] !== 'function') return new _monkey.<span class="apidocCodeKeywordSpan
">MonkeyDefinition</span>(args[0]);

 return new _monkey.MonkeyDefinition(args);
};
Baobab.dynamicNode = Baobab.monkey;

/**
* Exposing some internals for convenience
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.dynamicNode" id="apidoc.element.baobab.dynamicNode">
        function <span class="apidocSignatureSpan">baobab.</span>dynamicNode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dynamicNode = function () {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key &lt; _len; _key++) {
    args[_key] = arguments[_key];
  }

  if (!args.length) throw new Error('Baobab.monkey: missing definition.');

  if (args.length === 1 &amp;&amp; typeof args[0] !== 'function') return new _monkey.MonkeyDefinition(args[0]);

  return new _monkey.MonkeyDefinition(args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.monkey" id="apidoc.element.baobab.monkey">
        function <span class="apidocSignatureSpan">baobab.</span>monkey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">monkey = function () {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key &lt; _len; _key++) {
    args[_key] = arguments[_key];
  }

  if (!args.length) throw new Error('Baobab.monkey: missing definition.');

  if (args.length === 1 &amp;&amp; typeof args[0] !== 'function') return new _monkey.MonkeyDefinition(args[0]);

  return new _monkey.MonkeyDefinition(args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baobab.Cursor" id="apidoc.module.baobab.Cursor">module baobab.Cursor</a></h1>


    <h2>
        <a href="#apidoc.element.baobab.Cursor.Cursor" id="apidoc.element.baobab.Cursor.Cursor">
        function <span class="apidocSignatureSpan">baobab.</span>Cursor
        <span class="apidocSignatureSpan">(tree, path, hash)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Cursor(tree, path, hash) {
  var _this = this;

  _classCallCheck(this, Cursor);

  _get(Object.getPrototypeOf(Cursor.prototype), 'constructor', this).call(this);

  // If no path were to be provided, we fallback to an empty path (root)
  path = path || [];

  // Privates
  this._identity = '[object Cursor]';
  this._archive = null;

  // Properties
  this.tree = tree;
  this.path = path;
  this.hash = hash;

  // State
  this.state = {
    killed: false,
    recording: false,
    undoing: false
  };

  // Checking whether the given path is dynamic or not
  this._dynamicPath = _type2['default'].dynamicPath(this.path);

  // Checking whether the given path will meet a monkey
  this._monkeyPath = _type2['default'].monkeyPath(this.tree._monkeys, this.path);

  if (!this._dynamicPath) this.solvedPath = this.path;else this.solvedPath = (0, _helpers.getIn)(this.tree._data, this.path).solvedPath
;

<span class="apidocCodeCommentSpan">  /**
   * Listener bound to the tree's writes so that cursors with dynamic paths
   * may update their solved path correctly.
   *
   * @param {object} event - The event fired by the tree.
   */
</span>  this._writeHandler = function (_ref) {
    var data = _ref.data;

    if (_this.state.killed || !(0, _helpers.solveUpdate)([data.path], _this._getComparedPaths())) return;

    _this.solvedPath = (0, _helpers.getIn)(_this.tree._data, _this.path).solvedPath;
  };

  /**
   * Function in charge of actually trigger the cursor's updates and
   * deal with the archived records.
   *
   * @note: probably should wrap the current solvedPath in closure to avoid
   * for tricky cases where it would fail.
   *
   * @param {mixed} previousData - the tree's previous data.
   */
  var fireUpdate = function fireUpdate(previousData) {
    var self = _this;

    var eventData = Object.defineProperties({}, {
      previousData: {
        get: function get() {
          return (0, _helpers.getIn)(previousData, self.solvedPath).data;
        },
        configurable: true,
        enumerable: true
      },
      currentData: {
        get: function get() {
          return self.get();
        },
        configurable: true,
        enumerable: true
      }
    });

    if (_this.state.recording &amp;&amp; !_this.state.undoing) _this.archive.add(eventData.previousData);

    _this.state.undoing = false;

    return _this.emit('update', eventData);
  };

  /**
   * Listener bound to the tree's updates and determining whether the
   * cursor is affected and should react accordingly.
   *
   * Note that this listener is lazily bound to the tree to be sure
   * one wouldn't leak listeners when only creating cursors for convenience
   * and not to listen to updates specifically.
   *
   * @param {object} event - The event fired by the tree.
   */
  this._updateHandler = function (event) {
    if (_this.state.killed) return;

    var _event$data = event.data;
    var paths = _event$data.paths;
    var previousData = _event$data.previousData;
    var update = fireUpdate.bind(_this, previousData);
    var comparedPaths = _this._getComparedPaths();

    if ((0, _helpers.solveUpdate)(paths, comparedPaths)) return update();
  };

  // Lazy binding
  var bound = false;
  this._lazyBind = function () {
    if (bound) return;

    bound = true;

    if (_this._dynamicPath) _this.tree.on('write', _this._writeHandler);

    return _this.tree.on('update', _this._updateHandler);
  };

  // If the path is dynamic, we actually need to listen to the tree
  if (this._dynamicPath) {
    this._lazyBind();
  } else {

    // Overriding the emitter `on` and `once` methods
    this.on = (0, _helpers.before)(this._lazyBind, this.on.bind(this));
    this.once = (0, _helpers.before)(this._lazyBind, this.once.bind(this));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baobab.Cursor.prototype" id="apidoc.module.baobab.Cursor.prototype">module baobab.Cursor.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.baobab.Cursor.prototype.apply" id="apidoc.element.baobab.Cursor.prototype.apply">
        function <span class="apidocSignatureSpan">baobab.Cursor.prototype.</span>apply
        <span class="apidocSignatureSpan">(path, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">apply = function (path, value) {

  // We should warn the user if he applies to many arguments to the function
  if (arguments.length &gt; 2) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': too many arguments.');

  // Handling arities
  if (arguments.length === 1 &amp;&amp; !INTRANSITIVE_SETTERS[name]) {
    value = path;
    path = [];
  }

  // Coerce path
  path = (0, _helpers.coercePath)(path);

  // Checking the path's validity
  if (!_type2['default'].path(path)) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': invalid path.', { path: path });

  // Checking the value's validity
  if (typeChecker &amp;&amp; !typeChecker(value)) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': invalid value.', { path: path
, value: value });

  // Checking the solvability of the cursor's dynamic path
  if (!this.solvedPath) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': the dynamic path of the cursor cannot be solved
.', { path: this.path });

  var fullPath = this.solvedPath.concat(path);

  // Filing the update to the tree
  return this.tree.update(fullPath, {
    type: name,
    value: value
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
var inc = function(nb) {
  return nb + 1;
};

// Applying the function
var newList = cursor.<span class="apidocCodeKeywordSpan">apply</span>(inc);

// Applying the function at key
var newList = cursor.apply('key', inc);

// Applying the function at path
var newList = cursor.apply(['one', 'two'], inc);
var newList = cursor.select('one', 'two').apply(inc);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.Cursor.prototype.concat" id="apidoc.element.baobab.Cursor.prototype.concat">
        function <span class="apidocSignatureSpan">baobab.Cursor.prototype.</span>concat
        <span class="apidocSignatureSpan">(path, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">concat = function (path, value) {

  // We should warn the user if he applies to many arguments to the function
  if (arguments.length &gt; 2) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': too many arguments.');

  // Handling arities
  if (arguments.length === 1 &amp;&amp; !INTRANSITIVE_SETTERS[name]) {
    value = path;
    path = [];
  }

  // Coerce path
  path = (0, _helpers.coercePath)(path);

  // Checking the path's validity
  if (!_type2['default'].path(path)) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': invalid path.', { path: path });

  // Checking the value's validity
  if (typeChecker &amp;&amp; !typeChecker(value)) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': invalid value.', { path: path
, value: value });

  // Checking the solvability of the cursor's dynamic path
  if (!this.solvedPath) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': the dynamic path of the cursor cannot be solved
.', { path: this.path });

  var fullPath = this.solvedPath.concat(path);

  // Filing the update to the tree
  return this.tree.update(fullPath, {
    type: name,
    value: value
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

&lt;h5 id="concat"&gt;tree/cursor.concat&lt;/h5&gt;

Concatenates a list into the selected list. This will of course fail if the selected node is not a list.

```js
// Concatenating a list
var newList = cursor.<span class="apidocCodeKeywordSpan">concat</span>(list);

// Concatenating a list in the list at key
var newList = cursor.concat('key', list);

// Concatenating into a nested path
var newList = cursor.concat(['one', 'two'], list);
var newList = cursor.select('one', 'two').concat(list);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.Cursor.prototype.deepMerge" id="apidoc.element.baobab.Cursor.prototype.deepMerge">
        function <span class="apidocSignatureSpan">baobab.Cursor.prototype.</span>deepMerge
        <span class="apidocSignatureSpan">(path, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deepMerge = function (path, value) {

  // We should warn the user if he applies to many arguments to the function
  if (arguments.length &gt; 2) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': too many arguments.');

  // Handling arities
  if (arguments.length === 1 &amp;&amp; !INTRANSITIVE_SETTERS[name]) {
    value = path;
    path = [];
  }

  // Coerce path
  path = (0, _helpers.coercePath)(path);

  // Checking the path's validity
  if (!_type2['default'].path(path)) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': invalid path.', { path: path });

  // Checking the value's validity
  if (typeChecker &amp;&amp; !typeChecker(value)) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': invalid value.', { path: path
, value: value });

  // Checking the solvability of the cursor's dynamic path
  if (!this.solvedPath) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': the dynamic path of the cursor cannot be solved
.', { path: this.path });

  var fullPath = this.solvedPath.concat(path);

  // Filing the update to the tree
  return this.tree.update(fullPath, {
    type: name,
    value: value
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

&lt;h5 id="deepMerge"&gt;tree/cursor.deepMerge&lt;/h5&gt;

Deep merges the selected object with another one. This will of course fail if the selected node is not an object.

```js
// Merging
var newList = cursor.<span class="apidocCodeKeywordSpan">deepMerge</span>({user: {name: 'John'}});

// Merging at key
var newList = cursor.deepMerge('key', {user: {name: 'John'}});

// Merging at path
var newList = cursor.deepMerge(['one', 'two'], {user: {name: 'John'}});
var newList = cursor.select('one', 'two').deepMerge({user: {name: 'John'}});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.Cursor.prototype.merge" id="apidoc.element.baobab.Cursor.prototype.merge">
        function <span class="apidocSignatureSpan">baobab.Cursor.prototype.</span>merge
        <span class="apidocSignatureSpan">(path, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">merge = function (path, value) {

  // We should warn the user if he applies to many arguments to the function
  if (arguments.length &gt; 2) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': too many arguments.');

  // Handling arities
  if (arguments.length === 1 &amp;&amp; !INTRANSITIVE_SETTERS[name]) {
    value = path;
    path = [];
  }

  // Coerce path
  path = (0, _helpers.coercePath)(path);

  // Checking the path's validity
  if (!_type2['default'].path(path)) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': invalid path.', { path: path });

  // Checking the value's validity
  if (typeChecker &amp;&amp; !typeChecker(value)) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': invalid value.', { path: path
, value: value });

  // Checking the solvability of the cursor's dynamic path
  if (!this.solvedPath) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': the dynamic path of the cursor cannot be solved
.', { path: this.path });

  var fullPath = this.solvedPath.concat(path);

  // Filing the update to the tree
  return this.tree.update(fullPath, {
    type: name,
    value: value
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

&lt;h5 id="merge"&gt;tree/cursor.merge&lt;/h5&gt;

Shallow merges the selected object with another one. This will of course fail if the selected node is not an object.

```js
// Merging
var newList = cursor.<span class="apidocCodeKeywordSpan">merge</span>({name: 'John'});

// Merging at key
var newList = cursor.merge('key', {name: 'John'});

// Merging at path
var newList = cursor.merge(['one', 'two'], {name: 'John'});
var newList = cursor.select('one', 'two').merge({name: 'John'});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.Cursor.prototype.pop" id="apidoc.element.baobab.Cursor.prototype.pop">
        function <span class="apidocSignatureSpan">baobab.Cursor.prototype.</span>pop
        <span class="apidocSignatureSpan">(path, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pop = function (path, value) {

  // We should warn the user if he applies to many arguments to the function
  if (arguments.length &gt; 2) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': too many arguments.');

  // Handling arities
  if (arguments.length === 1 &amp;&amp; !INTRANSITIVE_SETTERS[name]) {
    value = path;
    path = [];
  }

  // Coerce path
  path = (0, _helpers.coercePath)(path);

  // Checking the path's validity
  if (!_type2['default'].path(path)) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': invalid path.', { path: path });

  // Checking the value's validity
  if (typeChecker &amp;&amp; !typeChecker(value)) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': invalid value.', { path: path
, value: value });

  // Checking the solvability of the cursor's dynamic path
  if (!this.solvedPath) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': the dynamic path of the cursor cannot be solved
.', { path: this.path });

  var fullPath = this.solvedPath.concat(path);

  // Filing the update to the tree
  return this.tree.update(fullPath, {
    type: name,
    value: value
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

&lt;h5 id="pop"&gt;tree/cursor.pop&lt;/h5&gt;

Removes the last item of the selected list. This will of course fail if the selected node is not a list.

```js
// Popping the list
var newList = cursor.<span class="apidocCodeKeywordSpan">pop</span>();

// Popping the list at key
var newList = cursor.pop('key');

// Popping list at path
var newList = cursor.pop(['one', 'two']);
var newList = cursor.select('one', 'two').pop();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.Cursor.prototype.push" id="apidoc.element.baobab.Cursor.prototype.push">
        function <span class="apidocSignatureSpan">baobab.Cursor.prototype.</span>push
        <span class="apidocSignatureSpan">(path, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">push = function (path, value) {

  // We should warn the user if he applies to many arguments to the function
  if (arguments.length &gt; 2) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': too many arguments.');

  // Handling arities
  if (arguments.length === 1 &amp;&amp; !INTRANSITIVE_SETTERS[name]) {
    value = path;
    path = [];
  }

  // Coerce path
  path = (0, _helpers.coercePath)(path);

  // Checking the path's validity
  if (!_type2['default'].path(path)) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': invalid path.', { path: path });

  // Checking the value's validity
  if (typeChecker &amp;&amp; !typeChecker(value)) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': invalid value.', { path: path
, value: value });

  // Checking the solvability of the cursor's dynamic path
  if (!this.solvedPath) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': the dynamic path of the cursor cannot be solved
.', { path: this.path });

  var fullPath = this.solvedPath.concat(path);

  // Filing the update to the tree
  return this.tree.update(fullPath, {
    type: name,
    value: value
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var colorsCursor = tree.select('palette', 'colors');

colorsCursor.on('update', function() {
  console.log('Selected colors have updated!');
});

colorsCursor.<span class="apidocCodeKeywordSpan">push</span>('orange');
```

## Installation

If you want to use **Baobab** with node.js or browserify/webpack etc., you can use npm.

```sh
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.Cursor.prototype.set" id="apidoc.element.baobab.Cursor.prototype.set">
        function <span class="apidocSignatureSpan">baobab.Cursor.prototype.</span>set
        <span class="apidocSignatureSpan">(path, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (path, value) {

  // We should warn the user if he applies to many arguments to the function
  if (arguments.length &gt; 2) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': too many arguments.');

  // Handling arities
  if (arguments.length === 1 &amp;&amp; !INTRANSITIVE_SETTERS[name]) {
    value = path;
    path = [];
  }

  // Coerce path
  path = (0, _helpers.coercePath)(path);

  // Checking the path's validity
  if (!_type2['default'].path(path)) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': invalid path.', { path: path });

  // Checking the value's validity
  if (typeChecker &amp;&amp; !typeChecker(value)) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': invalid value.', { path: path
, value: value });

  // Checking the solvability of the cursor's dynamic path
  if (!this.solvedPath) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': the dynamic path of the cursor cannot be solved
.', { path: this.path });

  var fullPath = this.solvedPath.concat(path);

  // Filing the update to the tree
  return this.tree.update(fullPath, {
    type: name,
    value: value
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

*Example*

```js
var tree = new Baobab({hello: 'world'});

var initialState = tree.get();
tree.<span class="apidocCodeKeywordSpan">set</span>('hello', 'monde');

// After asynchronous update...
assert(initialState !== tree.get());
```

---
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.Cursor.prototype.shift" id="apidoc.element.baobab.Cursor.prototype.shift">
        function <span class="apidocSignatureSpan">baobab.Cursor.prototype.</span>shift
        <span class="apidocSignatureSpan">(path, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shift = function (path, value) {

  // We should warn the user if he applies to many arguments to the function
  if (arguments.length &gt; 2) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': too many arguments.');

  // Handling arities
  if (arguments.length === 1 &amp;&amp; !INTRANSITIVE_SETTERS[name]) {
    value = path;
    path = [];
  }

  // Coerce path
  path = (0, _helpers.coercePath)(path);

  // Checking the path's validity
  if (!_type2['default'].path(path)) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': invalid path.', { path: path });

  // Checking the value's validity
  if (typeChecker &amp;&amp; !typeChecker(value)) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': invalid value.', { path: path
, value: value });

  // Checking the solvability of the cursor's dynamic path
  if (!this.solvedPath) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': the dynamic path of the cursor cannot be solved
.', { path: this.path });

  var fullPath = this.solvedPath.concat(path);

  // Filing the update to the tree
  return this.tree.update(fullPath, {
    type: name,
    value: value
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

&lt;h5 id="shift"&gt;tree/cursor.shift&lt;/h5&gt;

Removes the first item of the selected list. This will of course fail if the selected node is not a list.

```js
// Shifting the list
var newList = cursor.<span class="apidocCodeKeywordSpan">shift</span>();

// Shifting the list at key
var newList = cursor.shift('key');

// Shifting list at path
var newList = cursor.shift(['one', 'two']);
var newList = cursor.select('one', 'two').shift();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.Cursor.prototype.splice" id="apidoc.element.baobab.Cursor.prototype.splice">
        function <span class="apidocSignatureSpan">baobab.Cursor.prototype.</span>splice
        <span class="apidocSignatureSpan">(path, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">splice = function (path, value) {

  // We should warn the user if he applies to many arguments to the function
  if (arguments.length &gt; 2) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': too many arguments.');

  // Handling arities
  if (arguments.length === 1 &amp;&amp; !INTRANSITIVE_SETTERS[name]) {
    value = path;
    path = [];
  }

  // Coerce path
  path = (0, _helpers.coercePath)(path);

  // Checking the path's validity
  if (!_type2['default'].path(path)) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': invalid path.', { path: path });

  // Checking the value's validity
  if (typeChecker &amp;&amp; !typeChecker(value)) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': invalid value.', { path: path
, value: value });

  // Checking the solvability of the cursor's dynamic path
  if (!this.solvedPath) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': the dynamic path of the cursor cannot be solved
.', { path: this.path });

  var fullPath = this.solvedPath.concat(path);

  // Filing the update to the tree
  return this.tree.update(fullPath, {
    type: name,
    value: value
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

The `splice` specifications works the same as for [`Array.prototype.splice`](https://developer.mozilla.org/fr/docs/Web/JavaScript
/Reference/Objets_globaux/Array/splice).
There is one exception though: Per specification, splice deletes no values if the `deleteCount` argument is not parseable as a number
.
The `splice` implementation of Baobab instead throws an error, if the given `deleteCount` argument could not be parsed.

```js
// Splicing the list
var newList = cursor.<span class="apidocCodeKeywordSpan">splice</span>([1, 1]);

// Omitting the deleteCount argument makes splice delete no elements.
var newList = cursor.splice([1]);

// Inserting an item etc.
var newList = cursor.splice([1, 0, 'newItem']);
var newList = cursor.splice([1, 0, 'newItem1', 'newItem2']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.Cursor.prototype.unset" id="apidoc.element.baobab.Cursor.prototype.unset">
        function <span class="apidocSignatureSpan">baobab.Cursor.prototype.</span>unset
        <span class="apidocSignatureSpan">(path, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unset = function (path, value) {

  // We should warn the user if he applies to many arguments to the function
  if (arguments.length &gt; 2) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': too many arguments.');

  // Handling arities
  if (arguments.length === 1 &amp;&amp; !INTRANSITIVE_SETTERS[name]) {
    value = path;
    path = [];
  }

  // Coerce path
  path = (0, _helpers.coercePath)(path);

  // Checking the path's validity
  if (!_type2['default'].path(path)) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': invalid path.', { path: path });

  // Checking the value's validity
  if (typeChecker &amp;&amp; !typeChecker(value)) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': invalid value.', { path: path
, value: value });

  // Checking the solvability of the cursor's dynamic path
  if (!this.solvedPath) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': the dynamic path of the cursor cannot be solved
.', { path: this.path });

  var fullPath = this.solvedPath.concat(path);

  // Filing the update to the tree
  return this.tree.update(fullPath, {
    type: name,
    value: value
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Unsets the given key.

It will also work if you want to delete a list's item.

```js
// Removing data at cursor
cursor.<span class="apidocCodeKeywordSpan">unset</span>();

// Removing a precise key
cursor.unset('key');

// Removing a nested key
cursor.unset(['one', 'two']);
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.Cursor.prototype.unshift" id="apidoc.element.baobab.Cursor.prototype.unshift">
        function <span class="apidocSignatureSpan">baobab.Cursor.prototype.</span>unshift
        <span class="apidocSignatureSpan">(path, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unshift = function (path, value) {

  // We should warn the user if he applies to many arguments to the function
  if (arguments.length &gt; 2) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': too many arguments.');

  // Handling arities
  if (arguments.length === 1 &amp;&amp; !INTRANSITIVE_SETTERS[name]) {
    value = path;
    path = [];
  }

  // Coerce path
  path = (0, _helpers.coercePath)(path);

  // Checking the path's validity
  if (!_type2['default'].path(path)) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': invalid path.', { path: path });

  // Checking the value's validity
  if (typeChecker &amp;&amp; !typeChecker(value)) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': invalid value.', { path: path
, value: value });

  // Checking the solvability of the cursor's dynamic path
  if (!this.solvedPath) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': the dynamic path of the cursor cannot be solved
.', { path: this.path });

  var fullPath = this.solvedPath.concat(path);

  // Filing the update to the tree
  return this.tree.update(fullPath, {
    type: name,
    value: value
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

&lt;h5 id="unshift"&gt;tree/cursor.unshift&lt;/h5&gt;

Unshifts a value into the selected list. This will of course fail if the selected node is not a list.

```js
// Unshifting a value
var newList = cursor.<span class="apidocCodeKeywordSpan">unshift</span>(newValue);

// Unshifting a value in the list at key
var newList = cursor.unshift('key', newValue);

// Unshifting into a nested path
var newList = cursor.unshift(['one', 'two'], newValue);
var newList = cursor.select('one', 'two').unshift(newValue);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baobab.helpers" id="apidoc.module.baobab.helpers">module baobab.helpers</a></h1>


    <h2>
        <a href="#apidoc.element.baobab.helpers.Archive" id="apidoc.element.baobab.helpers.Archive">
        function <span class="apidocSignatureSpan">baobab.helpers.</span>Archive
        <span class="apidocSignatureSpan">(size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Archive(size) {
  _classCallCheck(this, Archive);

  this.size = size;
  this.records = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.state.recording = true;

  if (this.archive) return this;

  // Lazy binding
  this._lazyBind();

  this.archive = new _helpers.<span class="apidocCodeKeywordSpan">Archive</span>(maxRecords);
  return this;
}

/**
 * Methods stopping to record the cursor's successive states.
 *
 * @return {Cursor} - The cursor instance for chaining purposes.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.helpers.arrayFrom" id="apidoc.element.baobab.helpers.arrayFrom">
        function <span class="apidocSignatureSpan">baobab.helpers.</span>arrayFrom
        <span class="apidocSignatureSpan">(culprit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function arrayFrom(culprit) {
  return slice(culprit);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.helpers.before" id="apidoc.element.baobab.helpers.before">
        function <span class="apidocSignatureSpan">baobab.helpers.</span>before
        <span class="apidocSignatureSpan">(decorator, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function before(decorator, fn) {
  return function () {
    decorator.apply(null, arguments);
    fn.apply(null, arguments);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.helpers.coercePath" id="apidoc.element.baobab.helpers.coercePath">
        function <span class="apidocSignatureSpan">baobab.helpers.</span>coercePath
        <span class="apidocSignatureSpan">(target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function coercePath(target) {
  if (target || target === 0 || target === '') return target;
  return [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.helpers.deepClone" id="apidoc.element.baobab.helpers.deepClone">
        function <span class="apidocSignatureSpan">baobab.helpers.</span>deepClone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deepClone = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.helpers.deepFreeze" id="apidoc.element.baobab.helpers.deepFreeze">
        function <span class="apidocSignatureSpan">baobab.helpers.</span>deepFreeze
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deepFreeze = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.helpers.deepMerge" id="apidoc.element.baobab.helpers.deepMerge">
        function <span class="apidocSignatureSpan">baobab.helpers.</span>deepMerge
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deepMerge = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...

&lt;h5 id="deepMerge"&gt;tree/cursor.deepMerge&lt;/h5&gt;

Deep merges the selected object with another one. This will of course fail if the selected node is not an object.

```js
// Merging
var newList = cursor.<span class="apidocCodeKeywordSpan">deepMerge</span>({user: {name: 'John'}});

// Merging at key
var newList = cursor.deepMerge('key', {user: {name: 'John'}});

// Merging at path
var newList = cursor.deepMerge(['one', 'two'], {user: {name: 'John'}});
var newList = cursor.select('one', 'two').deepMerge({user: {name: 'John'}});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.helpers.freeze" id="apidoc.element.baobab.helpers.freeze">
        function <span class="apidocSignatureSpan">baobab.helpers.</span>freeze
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">freeze = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param  {boolean} deep - Should we recursively freeze the given objects?
 * @param  {object}  o    - The variable to freeze.
 * @return {object}    - The merged object.
 */
function freezer(deep, o) {
  if (typeof o !== 'object' || o === null || o instanceof _monkey.Monkey) return;

  Object.<span class="apidocCodeKeywordSpan">freeze</span>(o);

  if (!deep) return;

  if (Array.isArray(o)) {

// Iterating through the elements
var i = undefined,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.helpers.getIn" id="apidoc.element.baobab.helpers.getIn">
        function <span class="apidocSignatureSpan">baobab.helpers.</span>getIn
        <span class="apidocSignatureSpan">(object, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getIn(object, path) {
  if (!path) return NOT_FOUND_OBJECT;

  var solvedPath = [];

  var exists = true,
      c = object,
      idx = undefined,
      i = undefined,
      l = undefined;

  for (i = 0, l = path.length; i &lt; l; i++) {
    if (!c) return {
      data: undefined,
      solvedPath: solvedPath.concat(path.slice(i)),
      exists: false
    };

    if (typeof path[i] === 'function') {
      if (!_type2['default'].array(c)) return NOT_FOUND_OBJECT;

      idx = index(c, path[i]);
      if (! ~idx) return NOT_FOUND_OBJECT;

      solvedPath.push(idx);
      c = c[idx];
    } else if (typeof path[i] === 'object') {
      if (!_type2['default'].array(c)) return NOT_FOUND_OBJECT;

      idx = index(c, function (e) {
        return compare(e, path[i]);
      });
      if (! ~idx) return NOT_FOUND_OBJECT;

      solvedPath.push(idx);
      c = c[idx];
    } else {
      solvedPath.push(path[i]);
      exists = typeof c === 'object' &amp;&amp; path[i] in c;
      c = c[path[i]];
    }
  }

  return { data: c, solvedPath: solvedPath, exists: exists };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.helpers.makeError" id="apidoc.element.baobab.helpers.makeError">
        function <span class="apidocSignatureSpan">baobab.helpers.</span>makeError
        <span class="apidocSignatureSpan">(message, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function makeError(message, data) {
  var err = new Error(message);

  for (var k in data) {
    err[k] = data[k];
  }return err;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.helpers.shallowClone" id="apidoc.element.baobab.helpers.shallowClone">
        function <span class="apidocSignatureSpan">baobab.helpers.</span>shallowClone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shallowClone = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.helpers.shallowMerge" id="apidoc.element.baobab.helpers.shallowMerge">
        function <span class="apidocSignatureSpan">baobab.helpers.</span>shallowMerge
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shallowMerge = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.helpers.solveRelativePath" id="apidoc.element.baobab.helpers.solveRelativePath">
        function <span class="apidocSignatureSpan">baobab.helpers.</span>solveRelativePath
        <span class="apidocSignatureSpan">(base, to)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function solveRelativePath(base, to) {
  var solvedPath = [];

  // Coercing to array
  to = [].concat(to);

  for (var i = 0, l = to.length; i &lt; l; i++) {
    var step = to[i];

    if (step === '.') {
      if (!i) solvedPath = base.slice(0);
    } else if (step === '..') {
      solvedPath = (!i ? base : solvedPath).slice(0, -1);
    } else {
      solvedPath.push(step);
    }
  }

  return solvedPath;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.helpers.solveUpdate" id="apidoc.element.baobab.helpers.solveUpdate">
        function <span class="apidocSignatureSpan">baobab.helpers.</span>solveUpdate
        <span class="apidocSignatureSpan">(affectedPaths, comparedPaths)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function solveUpdate(affectedPaths, comparedPaths) {
  var i = undefined,
      j = undefined,
      k = undefined,
      l = undefined,
      m = undefined,
      n = undefined,
      p = undefined,
      c = undefined,
      s = undefined;

  // Looping through possible paths
  for (i = 0, l = affectedPaths.length; i &lt; l; i++) {
    p = affectedPaths[i];

    if (!p.length) return true;

    // Looping through logged paths
    for (j = 0, m = comparedPaths.length; j &lt; m; j++) {
      c = comparedPaths[j];

      if (!c || !c.length) return true;

      // Looping through steps
      for (k = 0, n = c.length; k &lt; n; k++) {
        s = c[k];

        // If path is not relevant, we break
        // NOTE: the '!=' instead of '!==' is required here!
        if (s != p[k]) break;

        // If we reached last item and we are relevant
        if (k + 1 === n || k + 1 === p.length) return true;
      }
    }
  }

  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.helpers.splice" id="apidoc.element.baobab.helpers.splice">
        function <span class="apidocSignatureSpan">baobab.helpers.</span>splice
        <span class="apidocSignatureSpan">(array, startIndex, nb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function splice(array, startIndex, nb) {
  for (var _len2 = arguments.length, elements = Array(_len2 &gt; 3 ? _len2 - 3 : 0), _key2 = 3; _key2 &lt; _len2; _key2++) {
    elements[_key2 - 3] = arguments[_key2];
  }

  if (nb === undefined &amp;&amp; arguments.length === 2) nb = array.length - startIndex;else if (nb === null || nb === undefined) nb =
0;else if (isNaN(+nb)) throw new Error('argument nb ' + nb + ' can not be parsed into a number!');
  nb = Math.max(0, nb);

  // Solving startIndex
  if (_type2['default']['function'](startIndex)) startIndex = index(array, startIndex);
  if (_type2['default'].object(startIndex)) startIndex = index(array, function (e) {
    return compare(e, startIndex);
  });

  // Positive index
  if (startIndex &gt;= 0) return array.slice(0, startIndex).concat(elements).concat(array.slice(startIndex + nb));

  // Negative index
  return array.slice(0, array.length + startIndex).concat(elements).concat(array.slice(array.length + startIndex + nb));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

The `splice` specifications works the same as for [`Array.prototype.splice`](https://developer.mozilla.org/fr/docs/Web/JavaScript
/Reference/Objets_globaux/Array/splice).
There is one exception though: Per specification, splice deletes no values if the `deleteCount` argument is not parseable as a number
.
The `splice` implementation of Baobab instead throws an error, if the given `deleteCount` argument could not be parsed.

```js
// Splicing the list
var newList = cursor.<span class="apidocCodeKeywordSpan">splice</span>([1, 1]);

// Omitting the deleteCount argument makes splice delete no elements.
var newList = cursor.splice([1]);

// Inserting an item etc.
var newList = cursor.splice([1, 0, 'newItem']);
var newList = cursor.splice([1, 0, 'newItem1', 'newItem2']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.helpers.uniqid" id="apidoc.element.baobab.helpers.uniqid">
        function <span class="apidocSignatureSpan">baobab.helpers.</span>uniqid
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">uniqid = function () {
  return i++;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baobab.type" id="apidoc.module.baobab.type">module baobab.type</a></h1>


    <h2>
        <a href="#apidoc.element.baobab.type.array" id="apidoc.element.baobab.type.array">
        function <span class="apidocSignatureSpan">baobab.type.</span>array
        <span class="apidocSignatureSpan">(target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">array = function (target) {
  return Array.isArray(target);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

_get(Object.getPrototypeOf(Baobab.prototype), 'constructor', this).call(this);

// Setting initialData to an empty object if no data is provided by use
if (arguments.length &lt; 1) initialData = {};

// Checking whether given initial data is valid
if (!_type2['default'].object(initialData) &amp;&amp; !_type2['default'].<span class="apidocCodeKeywordSpan
">array</span>(initialData)) throw makeError('Baobab: invalid data.', { data: initialData });

// Merging given options with defaults
this.options = shallowMerge({}, DEFAULTS, opts);

// Disabling immutability &amp; persistence if persistence if disabled
if (!this.options.persistent) {
  this.options.immutable = false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.type.dynamicPath" id="apidoc.element.baobab.type.dynamicPath">
        function <span class="apidocSignatureSpan">baobab.type.</span>dynamicPath
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dynamicPath = function (path) {
  return path.some(function (step) {
    return type['function'](step) || type.object(step);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.state = {
  killed: false,
  recording: false,
  undoing: false
};

// Checking whether the given path is dynamic or not
this._dynamicPath = _type2['default'].<span class="apidocCodeKeywordSpan">dynamicPath</span>(this.path);

// Checking whether the given path will meet a monkey
this._monkeyPath = _type2['default'].monkeyPath(this.tree._monkeys, this.path);

if (!this._dynamicPath) this.solvedPath = this.path;else this.solvedPath = (0, _helpers.getIn)(this.tree._data, this.path).solvedPath
;

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.type.function" id="apidoc.element.baobab.type.function">
        function <span class="apidocSignatureSpan">baobab.type.</span>function
        <span class="apidocSignatureSpan">(target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function = function (target) {
  return typeof target === 'function';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * array.
 *
 * @param  {array}  path - The path to hash.
 * @return {string} string - The resultant hash.
 */
function hashPath(path) {
  return 'Î»' + path.map(step =&gt; {
    if (type.<span class="apidocCodeKeywordSpan">function</span>(step) || type.object(step))
      return `#${uniqid()}#`;

    return step;
  }).join('Î»');
}

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.type.lazyGetter" id="apidoc.element.baobab.type.lazyGetter">
        function <span class="apidocSignatureSpan">baobab.type.</span>lazyGetter
        <span class="apidocSignatureSpan">(o, propertyKey)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lazyGetter = function (o, propertyKey) {
  var descriptor = Object.getOwnPropertyDescriptor(o, propertyKey);

  return descriptor &amp;&amp; descriptor.get &amp;&amp; descriptor.get.isLazyGetter === true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    l = undefined,
    k = undefined;

// NOTE: could be possible to erase computed properties through `null`.
var props = Object.getOwnPropertyNames(item);
for (i = 0, l = props.length; i &lt; l; i++) {
  k = props[i];
  if (_type2['default'].<span class="apidocCodeKeywordSpan">lazyGetter</span>(item, k)) {
    Object.defineProperty(o, k, {
      get: Object.getOwnPropertyDescriptor(item, k).get,
      enumerable: true,
      configurable: true
    });
  } else {
    Object.defineProperty(o, k, {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.type.monkeyDefinition" id="apidoc.element.baobab.type.monkeyDefinition">
        function <span class="apidocSignatureSpan">baobab.type.</span>monkeyDefinition
        <span class="apidocSignatureSpan">(definition)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">monkeyDefinition = function (definition) {

  if (type.object(definition)) {
    if (!type['function'](definition.get) || definition.cursors &amp;&amp; (!type.object(definition.cursors) || !Object.keys(definition.
cursors).every(function (k) {
      return type.path(definition.cursors[k]);
    }))) return null;

    return 'object';
  } else if (type.array(definition)) {
    var offset = 1;

    if (type.object(definition[definition.length - 1])) offset++;

    if (!type['function'](definition[definition.length - offset]) || !definition.slice(0, -offset).every(function (p) {
      return type.path(p);
    })) return null;

    return 'array';
  }

  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */

var MonkeyDefinition = function MonkeyDefinition(definition) {
var _this = this;

_classCallCheck(this, MonkeyDefinition);

var monkeyType = _type2['default'].<span class="apidocCodeKeywordSpan">monkeyDefinition</span>(definition);

if (!monkeyType) throw (0, _helpers.makeError)('Baobab.monkey: invalid definition.', { definition: definition });

this.type = monkeyType;

if (this.type === 'object') {
  this.getter = definition.get;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.type.monkeyPath" id="apidoc.element.baobab.type.monkeyPath">
        function <span class="apidocSignatureSpan">baobab.type.</span>monkeyPath
        <span class="apidocSignatureSpan">(data, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">monkeyPath = function (data, path) {
  var subpath = [];

  var c = data,
      i = undefined,
      l = undefined;

  for (i = 0, l = path.length; i &lt; l; i++) {
    subpath.push(path[i]);

    if (typeof c !== 'object') return null;

    c = c[path[i]];

    if (c instanceof _monkey.Monkey) return subpath;
  }

  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// If we couldn't solve the path, we throw
if (!solvedPath) throw makeError('Baobab.update: could not solve the given path.', {
  path: solvedPath
});

// Read-only path?
var monkeyPath = _type2['default'].<span class="apidocCodeKeywordSpan">monkeyPath</span>(this._monkeys, solvedPath);
if (monkeyPath &amp;&amp; solvedPath.length &gt; monkeyPath.length) throw makeError('Baobab.update: attempting to update
 a read-only path.', {
  path: solvedPath
});

// We don't unset irrelevant paths
if (operation.type === 'unset' &amp;&amp; !exists) return;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.type.number" id="apidoc.element.baobab.type.number">
        function <span class="apidocSignatureSpan">baobab.type.</span>number
        <span class="apidocSignatureSpan">(target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">number = function (target) {
  return typeof target === 'number';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.type.object" id="apidoc.element.baobab.type.object">
        function <span class="apidocSignatureSpan">baobab.type.</span>object
        <span class="apidocSignatureSpan">(target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">object = function (target) {
  return target &amp;&amp; typeof target === 'object' &amp;&amp; !Array.isArray(target) &amp;&amp; !(target instanceof Date) &amp;&amp; !(target instanceof RegExp
) &amp;&amp; !(typeof Map === 'function' &amp;&amp; target instanceof Map) &amp;&amp; !(typeof Set === 'function' &amp;&amp; target instanceof Set);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* array.
*
* @param  {array}  path - The path to hash.
* @return {string} string - The resultant hash.
*/
function hashPath(path) {
 return 'Î»' + path.map(function (step) {
   if (_type2['default']['function'](step) || _type2['default'].<span class="apidocCodeKeywordSpan
">object</span>(step)) return '#' + uniqid() + '#';

   return step;
 }).join('Î»');
}

/**
* Baobab class
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.type.operationType" id="apidoc.element.baobab.type.operationType">
        function <span class="apidocSignatureSpan">baobab.type.</span>operationType
        <span class="apidocSignatureSpan">(string)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">operationType = function (string) {
  return typeof string === 'string' &amp;&amp; !! ~VALID_OPERATIONS.indexOf(string);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    key: 'update',
    value: function update(path, operation) {
var _this3 = this;

// Coercing path
path = coercePath(path);

if (!_type2['default'].<span class="apidocCodeKeywordSpan">operationType</span>(operation.type)) throw makeError('
;Baobab.update: unknown operation type "' + operation.type + '".', { operation: operation });

// Solving the given path

var _getIn = getIn(this._data, path);

var solvedPath = _getIn.solvedPath;
var exists = _getIn.exists;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.type.path" id="apidoc.element.baobab.type.path">
        function <span class="apidocSignatureSpan">baobab.type.</span>path
        <span class="apidocSignatureSpan">(target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">path = function (target) {
  if (!target &amp;&amp; target !== 0 &amp;&amp; target !== '') return false;

  return [].concat(target).every(function (step) {
    return anyOf(step, ALLOWED_FOR_PATH);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// If no path is given, we simply return the root
path = path || [];

// Variadic
if (arguments.length &gt; 1) path = arrayFrom(arguments);

// Checking that given path is valid
if (!_type2['default'].<span class="apidocCodeKeywordSpan">path</span>(path)) throw makeError('Baobab.select: invalid
 path.', { path: path });

// Casting to array
path = [].concat(path);

// Computing hash (done here because it would be too late to do it in the
// cursor's constructor since we need to hit the cursors' index first).
var hash = hashPath(path);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.type.primitive" id="apidoc.element.baobab.type.primitive">
        function <span class="apidocSignatureSpan">baobab.type.</span>primitive
        <span class="apidocSignatureSpan">(target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">primitive = function (target) {
  return target !== Object(target);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Method returning whether the cursor is at leaf level.
 *
 * @return {boolean} - Is the cursor a leaf?
 */
  }, {
key: 'isLeaf',
value: function isLeaf() {
  return _type2['default'].<span class="apidocCodeKeywordSpan">primitive</span>(this._get().data);
}

/**
 * Method returning whether the cursor is at branch level.
 *
 * @return {boolean} - Is the cursor a branch?
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.type.splicer" id="apidoc.element.baobab.type.splicer">
        function <span class="apidocSignatureSpan">baobab.type.</span>splicer
        <span class="apidocSignatureSpan">(target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">splicer = function (target) {
  if (!type.array(target) || target.length &lt; 1) return false;
  if (target.length &gt; 1 &amp;&amp; isNaN(+target[1])) return false;

  return anyOf(target[0], ['number', 'function', 'object']);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.type.string" id="apidoc.element.baobab.type.string">
        function <span class="apidocSignatureSpan">baobab.type.</span>string
        <span class="apidocSignatureSpan">(target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">string = function (target) {
  return typeof target === 'string';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baobab.type.watcherMapping" id="apidoc.element.baobab.type.watcherMapping">
        function <span class="apidocSignatureSpan">baobab.type.</span>watcherMapping
        <span class="apidocSignatureSpan">(definition)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">watcherMapping = function (definition) {
  return type.object(definition) &amp;&amp; Object.keys(definition).every(function (k) {
    return type.path(definition[k]);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * @param  {object}  mapping  - The new mapping to apply.
     * @return {Watcher}          - Itself for chaining purposes.
     */
  }, {
    key: 'refresh',
    value: function refresh(mapping) {

if (!_type2['default'].<span class="apidocCodeKeywordSpan">watcherMapping</span>(mapping)) throw (0, _helpers.makeError
)('Baobab.watch: invalid mapping.', { mapping: mapping });

this.mapping = mapping;

// Creating the get method
var projection = {};

for (var k in mapping) {
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>